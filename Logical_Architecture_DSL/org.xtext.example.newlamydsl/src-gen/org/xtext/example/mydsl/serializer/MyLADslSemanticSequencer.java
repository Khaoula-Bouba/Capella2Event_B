/*
 * generated by Xtext 2.22.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myLADsl.AbstractCapabilityPkg;
import org.xtext.example.mydsl.myLADsl.AbstractDeploymentLink;
import org.xtext.example.mydsl.myLADsl.AbstractFunction;
import org.xtext.example.mydsl.myLADsl.AbstractPropertyValue;
import org.xtext.example.mydsl.myLADsl.AbstractType;
import org.xtext.example.mydsl.myLADsl.ActivityEdge;
import org.xtext.example.mydsl.myLADsl.ActivityGroup;
import org.xtext.example.mydsl.myLADsl.ActivityNode;
import org.xtext.example.mydsl.myLADsl.CommunicationLink;
import org.xtext.example.mydsl.myLADsl.ComponentExchange;
import org.xtext.example.mydsl.myLADsl.ComponentExchangeAllocation;
import org.xtext.example.mydsl.myLADsl.ComponentExchangeCategory;
import org.xtext.example.mydsl.myLADsl.ComponentExchangeEnd;
import org.xtext.example.mydsl.myLADsl.ComponentExchangeFunctionalExchangeAllocation;
import org.xtext.example.mydsl.myLADsl.ComponentExchangeRealization;
import org.xtext.example.mydsl.myLADsl.ComponentFunctionalAllocation;
import org.xtext.example.mydsl.myLADsl.ComponentRealization;
import org.xtext.example.mydsl.myLADsl.Constraint;
import org.xtext.example.mydsl.myLADsl.ControlNode;
import org.xtext.example.mydsl.myLADsl.DataPkg;
import org.xtext.example.mydsl.myLADsl.DataPkgs;
import org.xtext.example.mydsl.myLADsl.DataType;
import org.xtext.example.mydsl.myLADsl.EnumerationPropertyLiteral;
import org.xtext.example.mydsl.myLADsl.EnumerationPropertyType;
import org.xtext.example.mydsl.myLADsl.ExceptionHandler;
import org.xtext.example.mydsl.myLADsl.ExchangeCategory;
import org.xtext.example.mydsl.myLADsl.ExchangeContainment;
import org.xtext.example.mydsl.myLADsl.ExchangeItem;
import org.xtext.example.mydsl.myLADsl.ExchangeItemAllocation;
import org.xtext.example.mydsl.myLADsl.ExchangeItemElement;
import org.xtext.example.mydsl.myLADsl.ExchangeLink;
import org.xtext.example.mydsl.myLADsl.ExchangeSpecificationRealization;
import org.xtext.example.mydsl.myLADsl.Feature;
import org.xtext.example.mydsl.myLADsl.FunctionInputPort;
import org.xtext.example.mydsl.myLADsl.FunctionRealization;
import org.xtext.example.mydsl.myLADsl.FunctionSpecification;
import org.xtext.example.mydsl.myLADsl.FunctionalChain;
import org.xtext.example.mydsl.myLADsl.FunctionalChainInvolvementLink;
import org.xtext.example.mydsl.myLADsl.FunctionalChainRealization;
import org.xtext.example.mydsl.myLADsl.FunctionalExchange;
import org.xtext.example.mydsl.myLADsl.FunctionalExchangeRealization;
import org.xtext.example.mydsl.myLADsl.FunctionalExchangeSpecification;
import org.xtext.example.mydsl.myLADsl.Generalization;
import org.xtext.example.mydsl.myLADsl.InformationRealization;
import org.xtext.example.mydsl.myLADsl.Initialization;
import org.xtext.example.mydsl.myLADsl.Interface;
import org.xtext.example.mydsl.myLADsl.InterfaceAllocation;
import org.xtext.example.mydsl.myLADsl.InterfaceImplementation;
import org.xtext.example.mydsl.myLADsl.InterfacePkg;
import org.xtext.example.mydsl.myLADsl.InterfaceUse;
import org.xtext.example.mydsl.myLADsl.Invariant;
import org.xtext.example.mydsl.myLADsl.LogicalArchitecture;
import org.xtext.example.mydsl.myLADsl.LogicalComponent;
import org.xtext.example.mydsl.myLADsl.LogicalComponentPkg;
import org.xtext.example.mydsl.myLADsl.LogicalFunction;
import org.xtext.example.mydsl.myLADsl.LogicalFunctionPkg;
import org.xtext.example.mydsl.myLADsl.Message;
import org.xtext.example.mydsl.myLADsl.MessageReference;
import org.xtext.example.mydsl.myLADsl.MyLADslPackage;
import org.xtext.example.mydsl.myLADsl.OpaqueExpression;
import org.xtext.example.mydsl.myLADsl.Part;
import org.xtext.example.mydsl.myLADsl.PhysicalLink;
import org.xtext.example.mydsl.myLADsl.PhysicalLinkCategory;
import org.xtext.example.mydsl.myLADsl.PhysicalLinkEnd;
import org.xtext.example.mydsl.myLADsl.PhysicalLinkRealization;
import org.xtext.example.mydsl.myLADsl.PhysicalPath;
import org.xtext.example.mydsl.myLADsl.PhysicalPathInvolvement;
import org.xtext.example.mydsl.myLADsl.PhysicalPathRealization;
import org.xtext.example.mydsl.myLADsl.PortAllocation;
import org.xtext.example.mydsl.myLADsl.PortRealization;
import org.xtext.example.mydsl.myLADsl.PropertyValueGroup;
import org.xtext.example.mydsl.myLADsl.PropertyValuePkg;
import org.xtext.example.mydsl.myLADsl.Region;
import org.xtext.example.mydsl.myLADsl.Requirement;
import org.xtext.example.mydsl.myLADsl.RequirementsPkg;
import org.xtext.example.mydsl.myLADsl.SequenceLink;
import org.xtext.example.mydsl.myLADsl.StateMachine;
import org.xtext.example.mydsl.myLADsl.StateTransition;
import org.xtext.example.mydsl.myLADsl.StateTransitionRealization;
import org.xtext.example.mydsl.myLADsl.SystemAnalysisRealization;
import org.xtext.example.mydsl.myLADsl.Trace;
import org.xtext.example.mydsl.myLADsl.ValueSpecification;
import org.xtext.example.mydsl.myLADsl.ValueTag;
import org.xtext.example.mydsl.services.MyLADslGrammarAccess;

@SuppressWarnings("all")
public class MyLADslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyLADslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyLADslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyLADslPackage.ABSTRACT_CAPABILITY_PKG:
				sequence_AbstractCapabilityPkg(context, (AbstractCapabilityPkg) semanticObject); 
				return; 
			case MyLADslPackage.ABSTRACT_DEPLOYMENT_LINK:
				sequence_AbstractDeploymentLink(context, (AbstractDeploymentLink) semanticObject); 
				return; 
			case MyLADslPackage.ABSTRACT_FUNCTION:
				sequence_AbstractFunction(context, (AbstractFunction) semanticObject); 
				return; 
			case MyLADslPackage.ABSTRACT_PROPERTY_VALUE:
				sequence_AbstractPropertyValue(context, (AbstractPropertyValue) semanticObject); 
				return; 
			case MyLADslPackage.ABSTRACT_TYPE:
				sequence_AbstractType(context, (AbstractType) semanticObject); 
				return; 
			case MyLADslPackage.ACTIVITY_EDGE:
				sequence_ActivityEdge(context, (ActivityEdge) semanticObject); 
				return; 
			case MyLADslPackage.ACTIVITY_GROUP:
				sequence_ActivityGroup(context, (ActivityGroup) semanticObject); 
				return; 
			case MyLADslPackage.ACTIVITY_NODE:
				sequence_ActivityNode(context, (ActivityNode) semanticObject); 
				return; 
			case MyLADslPackage.COMMUNICATION_LINK:
				sequence_CommunicationLink(context, (CommunicationLink) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_EXCHANGE:
				sequence_ComponentExchange(context, (ComponentExchange) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_EXCHANGE_ALLOCATION:
				sequence_ComponentExchangeAllocation(context, (ComponentExchangeAllocation) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_EXCHANGE_CATEGORY:
				sequence_ComponentExchangeCategory(context, (ComponentExchangeCategory) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_EXCHANGE_END:
				sequence_ComponentExchangeEnd(context, (ComponentExchangeEnd) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_EXCHANGE_FUNCTIONAL_EXCHANGE_ALLOCATION:
				sequence_ComponentExchangeFunctionalExchangeAllocation(context, (ComponentExchangeFunctionalExchangeAllocation) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_EXCHANGE_REALIZATION:
				sequence_ComponentExchangeRealization(context, (ComponentExchangeRealization) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_FUNCTIONAL_ALLOCATION:
				sequence_ComponentFunctionalAllocation(context, (ComponentFunctionalAllocation) semanticObject); 
				return; 
			case MyLADslPackage.COMPONENT_REALIZATION:
				sequence_ComponentRealization(context, (ComponentRealization) semanticObject); 
				return; 
			case MyLADslPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case MyLADslPackage.CONTROL_NODE:
				sequence_ControlNode(context, (ControlNode) semanticObject); 
				return; 
			case MyLADslPackage.DATA_PKG:
				sequence_DataPkg(context, (DataPkg) semanticObject); 
				return; 
			case MyLADslPackage.DATA_PKGS:
				sequence_DataPkgs(context, (DataPkgs) semanticObject); 
				return; 
			case MyLADslPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case MyLADslPackage.ENUMERATION_PROPERTY_LITERAL:
				sequence_EnumerationPropertyLiteral(context, (EnumerationPropertyLiteral) semanticObject); 
				return; 
			case MyLADslPackage.ENUMERATION_PROPERTY_TYPE:
				sequence_EnumerationPropertyType(context, (EnumerationPropertyType) semanticObject); 
				return; 
			case MyLADslPackage.EXCEPTION_HANDLER:
				sequence_ExceptionHandler(context, (ExceptionHandler) semanticObject); 
				return; 
			case MyLADslPackage.EXCHANGE_CATEGORY:
				sequence_ExchangeCategory(context, (ExchangeCategory) semanticObject); 
				return; 
			case MyLADslPackage.EXCHANGE_CONTAINMENT:
				sequence_ExchangeContainment(context, (ExchangeContainment) semanticObject); 
				return; 
			case MyLADslPackage.EXCHANGE_ITEM:
				sequence_ExchangeItem(context, (ExchangeItem) semanticObject); 
				return; 
			case MyLADslPackage.EXCHANGE_ITEM_ALLOCATION:
				sequence_ExchangeItemAllocation(context, (ExchangeItemAllocation) semanticObject); 
				return; 
			case MyLADslPackage.EXCHANGE_ITEM_ELEMENT:
				sequence_ExchangeItemElement(context, (ExchangeItemElement) semanticObject); 
				return; 
			case MyLADslPackage.EXCHANGE_LINK:
				sequence_ExchangeLink(context, (ExchangeLink) semanticObject); 
				return; 
			case MyLADslPackage.EXCHANGE_SPECIFICATION_REALIZATION:
				sequence_ExchangeSpecificationRealization(context, (ExchangeSpecificationRealization) semanticObject); 
				return; 
			case MyLADslPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTION_INPUT_PORT:
				sequence_InputOutputPin(context, (FunctionInputPort) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTION_REALIZATION:
				sequence_FunctionRealization(context, (FunctionRealization) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTION_SPECIFICATION:
				sequence_FunctionSpecification(context, (FunctionSpecification) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTIONAL_CHAIN:
				sequence_FunctionalChain(context, (FunctionalChain) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTIONAL_CHAIN_INVOLVEMENT_LINK:
				sequence_FunctionalChainInvolvement(context, (FunctionalChainInvolvementLink) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTIONAL_CHAIN_REALIZATION:
				sequence_FunctionalChainRealization(context, (FunctionalChainRealization) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTIONAL_EXCHANGE:
				sequence_FunctionalExchange(context, (FunctionalExchange) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTIONAL_EXCHANGE_REALIZATION:
				sequence_FunctionalExchangeRealization(context, (FunctionalExchangeRealization) semanticObject); 
				return; 
			case MyLADslPackage.FUNCTIONAL_EXCHANGE_SPECIFICATION:
				sequence_FunctionalExchangeSpecification(context, (FunctionalExchangeSpecification) semanticObject); 
				return; 
			case MyLADslPackage.GENERALIZATION:
				sequence_Generalization(context, (Generalization) semanticObject); 
				return; 
			case MyLADslPackage.INFORMATION_REALIZATION:
				sequence_InformationRealization(context, (InformationRealization) semanticObject); 
				return; 
			case MyLADslPackage.INITIALIZATION:
				sequence_Initialization(context, (Initialization) semanticObject); 
				return; 
			case MyLADslPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case MyLADslPackage.INTERFACE_ALLOCATION:
				sequence_InterfaceAllocation(context, (InterfaceAllocation) semanticObject); 
				return; 
			case MyLADslPackage.INTERFACE_IMPLEMENTATION:
				sequence_InterfaceImplementation(context, (InterfaceImplementation) semanticObject); 
				return; 
			case MyLADslPackage.INTERFACE_PKG:
				sequence_InterfacePkg(context, (InterfacePkg) semanticObject); 
				return; 
			case MyLADslPackage.INTERFACE_USE:
				sequence_InterfaceUse(context, (InterfaceUse) semanticObject); 
				return; 
			case MyLADslPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case MyLADslPackage.LOGICAL_ARCHITECTURE:
				sequence_LogicalArchitecture(context, (LogicalArchitecture) semanticObject); 
				return; 
			case MyLADslPackage.LOGICAL_COMPONENT:
				sequence_LogicalComponent(context, (LogicalComponent) semanticObject); 
				return; 
			case MyLADslPackage.LOGICAL_COMPONENT_PKG:
				sequence_LogicalComponentPkg(context, (LogicalComponentPkg) semanticObject); 
				return; 
			case MyLADslPackage.LOGICAL_FUNCTION:
				sequence_LogicalFunction(context, (LogicalFunction) semanticObject); 
				return; 
			case MyLADslPackage.LOGICAL_FUNCTION_PKG:
				sequence_LogicalFunctionPkg(context, (LogicalFunctionPkg) semanticObject); 
				return; 
			case MyLADslPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case MyLADslPackage.MESSAGE_REFERENCE:
				sequence_MessageReference(context, (MessageReference) semanticObject); 
				return; 
			case MyLADslPackage.OPAQUE_EXPRESSION:
				sequence_OpaqueExpression(context, (OpaqueExpression) semanticObject); 
				return; 
			case MyLADslPackage.PART:
				sequence_Part(context, (Part) semanticObject); 
				return; 
			case MyLADslPackage.PHYSICAL_LINK:
				sequence_PhysicalLink(context, (PhysicalLink) semanticObject); 
				return; 
			case MyLADslPackage.PHYSICAL_LINK_CATEGORY:
				sequence_PhysicalLinkCategory(context, (PhysicalLinkCategory) semanticObject); 
				return; 
			case MyLADslPackage.PHYSICAL_LINK_END:
				sequence_PhysicalLinkEnd(context, (PhysicalLinkEnd) semanticObject); 
				return; 
			case MyLADslPackage.PHYSICAL_LINK_REALIZATION:
				sequence_PhysicalLinkRealization(context, (PhysicalLinkRealization) semanticObject); 
				return; 
			case MyLADslPackage.PHYSICAL_PATH:
				sequence_PhysicalPath(context, (PhysicalPath) semanticObject); 
				return; 
			case MyLADslPackage.PHYSICAL_PATH_INVOLVEMENT:
				sequence_PhysicalPathInvolvement(context, (PhysicalPathInvolvement) semanticObject); 
				return; 
			case MyLADslPackage.PHYSICAL_PATH_REALIZATION:
				sequence_PhysicalPathRealization(context, (PhysicalPathRealization) semanticObject); 
				return; 
			case MyLADslPackage.PORT_ALLOCATION:
				sequence_PortAllocation(context, (PortAllocation) semanticObject); 
				return; 
			case MyLADslPackage.PORT_REALIZATION:
				sequence_PortRealization(context, (PortRealization) semanticObject); 
				return; 
			case MyLADslPackage.PROPERTY_VALUE_GROUP:
				sequence_PropertyValueGroup(context, (PropertyValueGroup) semanticObject); 
				return; 
			case MyLADslPackage.PROPERTY_VALUE_PKG:
				sequence_PropertyValuePkg(context, (PropertyValuePkg) semanticObject); 
				return; 
			case MyLADslPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case MyLADslPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case MyLADslPackage.REQUIREMENTS_PKG:
				sequence_RequirementsPkg(context, (RequirementsPkg) semanticObject); 
				return; 
			case MyLADslPackage.SEQUENCE_LINK:
				sequence_SequenceLink(context, (SequenceLink) semanticObject); 
				return; 
			case MyLADslPackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case MyLADslPackage.STATE_TRANSITION:
				sequence_StateTransition(context, (StateTransition) semanticObject); 
				return; 
			case MyLADslPackage.STATE_TRANSITION_REALIZATION:
				sequence_StateTransitionRealization(context, (StateTransitionRealization) semanticObject); 
				return; 
			case MyLADslPackage.SYSTEM_ANALYSIS_REALIZATION:
				sequence_SystemAnalysisRealization(context, (SystemAnalysisRealization) semanticObject); 
				return; 
			case MyLADslPackage.TRACE:
				sequence_Trace(context, (Trace) semanticObject); 
				return; 
			case MyLADslPackage.VALUE_SPECIFICATION:
				sequence_ValueSpecification(context, (ValueSpecification) semanticObject); 
				return; 
			case MyLADslPackage.VALUE_TAG:
				sequence_ValueTag(context, (ValueTag) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractCapabilityPkg returns AbstractCapabilityPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg*
	 *     )
	 */
	protected void sequence_AbstractCapabilityPkg(ISerializationContext context, AbstractCapabilityPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractDeploymentLink returns AbstractDeploymentLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         deployedElement=EString 
	 *         location=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_AbstractDeploymentLink(ISerializationContext context, AbstractDeploymentLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractFunction returns AbstractFunction
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         aggregationKind=EString? 
	 *         idType=EString? 
	 *         kind=EString? 
	 *         condition=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         context=EString? 
	 *         behavior=EString? 
	 *         availableInStates=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusiv=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedConstraints+=Constraint* 
	 *         ownedTraces+=Trace* 
	 *         ownedDefaultValue+=DataValue* 
	 *         ownedFunctionalChains+=FunctionalChain* 
	 *         ownedHandlers+=ExceptionHandler* 
	 *         inoutsOutputs+=InputOutputPin* 
	 *         ownedFunctions+=AbstractFunction* 
	 *         ownedFunctionRealizations+=FunctionRealization*
	 *     )
	 */
	protected void sequence_AbstractFunction(ISerializationContext context, AbstractFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractPropertyValue returns AbstractPropertyValue
	 *
	 * Constraint:
	 *     (
	 *         strType=EString 
	 *         strId=EString 
	 *         sid=EString? 
	 *         strName=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         (value=EString | value2=EFloat)? 
	 *         stringAppliedPropertyValues=EString? 
	 *         stringAppliedPropertyValueGroups=EString? 
	 *         statut=EString? 
	 *         stringFeatures=EString? 
	 *         stringInvolvedElements=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         stringOwnedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         stringOwnedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_AbstractPropertyValue(ISerializationContext context, AbstractPropertyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractType returns AbstractType
	 *
	 * Constraint:
	 *     (type=EString id=EString sid=EString? name=nameType? idType=EString?)
	 */
	protected void sequence_AbstractType(ISerializationContext context, AbstractType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityEdge returns ActivityEdge
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         kindOfRate=EString? 
	 *         realizedFlow=EString? 
	 *         target=EString 
	 *         source=EString 
	 *         interrupts=EString? 
	 *         rate=EString? 
	 *         probability=EString? 
	 *         guard=EString? 
	 *         weight=EString?
	 *     )
	 */
	protected void sequence_ActivityEdge(ISerializationContext context, ActivityEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityGroup returns ActivityGroup
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         subGroups+=ActivityGroup* 
	 *         ownedNodes+=ActivityNode* 
	 *         ownedEdges+=ActivityEdge*
	 *     )
	 */
	protected void sequence_ActivityGroup(ISerializationContext context, ActivityGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns ActivityNode
	 *
	 * Constraint:
	 *     (type=EString id=EString sid=EString? name=nameType?)
	 */
	protected void sequence_ActivityNode(ISerializationContext context, ActivityNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommunicationLink returns CommunicationLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=EString? 
	 *         protocol=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchangeItem=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_CommunicationLink(ISerializationContext context, CommunicationLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeAllocation returns ComponentExchangeAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeAllocation(ISerializationContext context, ComponentExchangeAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeCategory returns ComponentExchangeCategory
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchanges=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeCategory(ISerializationContext context, ComponentExchangeCategory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeEnd returns ComponentExchangeEnd
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         port=EString? 
	 *         part=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeEnd(ISerializationContext context, ComponentExchangeEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeFunctionalExchangeAllocation returns ComponentExchangeFunctionalExchangeAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeFunctionalExchangeAllocation(ISerializationContext context, ComponentExchangeFunctionalExchangeAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeRealization returns ComponentExchangeRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         componentOwnedPropertyValues+=AbstractPropertyValue* 
	 *         componentEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         componentOwnedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeRealization(ISerializationContext context, ComponentExchangeRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchange returns ComponentExchange
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         realizations=EString? 
	 *         convoyedInformations=EString? 
	 *         source=EString 
	 *         target=EString 
	 *         link=EString? 
	 *         oriented=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedComponentExchangeFunctionalExchangeAllocations+=ComponentExchangeFunctionalExchangeAllocation* 
	 *         ownedComponentExchangeRealizations+=ComponentExchangeRealization* 
	 *         ownedComponentExchangeEnds+=ComponentExchangeEnd*
	 *     )
	 */
	protected void sequence_ComponentExchange(ISerializationContext context, ComponentExchange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentFunctionalAllocation returns ComponentFunctionalAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentFunctionalAllocation(ISerializationContext context, ComponentFunctionalAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentRealization returns ComponentRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentRealization(ISerializationContext context, ComponentRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         (name=Initialization | name=Invariant) 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         constrElmts=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup? 
	 *         exprSpecification+=OpaqueExpression?
	 *     )
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ControlNode returns ControlNode
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_ControlNode(ISerializationContext context, ControlNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataPkg returns DataPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedMessageReferences+=MessageReference* 
	 *         ownedDataPkgs+=DataPkgs* 
	 *         ownedDataTypes+=DataType* 
	 *         ownedMessages+=Message*
	 *     )
	 */
	protected void sequence_DataPkg(ISerializationContext context, DataPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataPkgs returns DataPkgs
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedMessageReferences+=MessageReference* 
	 *         ownedDataTypes+=DataType* 
	 *         ownedMessages+=Message*
	 *     )
	 */
	protected void sequence_DataPkgs(ISerializationContext context, DataPkgs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         discrete=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         pattern=EString? 
	 *         visibility=EString? 
	 *         kind=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         unit=EString? 
	 *         abstract=EString? 
	 *         final=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedInformationRealizations+=InformationRealization*
	 *     )
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationPropertyLiteral returns EnumerationPropertyLiteral
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=[AbstractPropertyValue|EString]? 
	 *         appliedPropertyValueGroups+=[PropertyValueGroup|EString]? 
	 *         statut=EString? 
	 *         features=[EnumerationPropertyLiteral|EString]? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_EnumerationPropertyLiteral(ISerializationContext context, EnumerationPropertyLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationPropertyType returns EnumerationPropertyType
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         statut=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedLiterals+=EnumerationPropertyLiteral?
	 *     )
	 */
	protected void sequence_EnumerationPropertyType(ISerializationContext context, EnumerationPropertyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExceptionHandler returns ExceptionHandler
	 *
	 * Constraint:
	 *     (type=EString handlerBody=EString exceptionInput=EString exceptionTypes=EString)
	 */
	protected void sequence_ExceptionHandler(ISerializationContext context, ExceptionHandler semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_Type()));
			if (transientValues.isValueTransient(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_HandlerBody()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_HandlerBody()));
			if (transientValues.isValueTransient(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_ExceptionInput()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_ExceptionInput()));
			if (transientValues.isValueTransient(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_ExceptionTypes()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLADslPackage.eINSTANCE.getExceptionHandler_ExceptionTypes()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getTypeEStringTerminalRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getHandlerBodyEStringTerminalRuleCall_4_0(), semanticObject.getHandlerBody());
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getExceptionInputEStringTerminalRuleCall_6_0(), semanticObject.getExceptionInput());
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getExceptionTypesEStringTerminalRuleCall_8_0(), semanticObject.getExceptionTypes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeCategory returns ExchangeCategory
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchanges=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeCategory(ISerializationContext context, ExchangeCategory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeContainment returns ExchangeContainment
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchange=EString 
	 *         link=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeContainment(ISerializationContext context, ExchangeContainment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeItemAllocation returns ExchangeItemAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         sendProtocol=EString? 
	 *         receiveProtocol=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         allocatedItem=EString? 
	 *         final=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeItemAllocation(ISerializationContext context, ExchangeItemAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeItemElement returns ExchangeItemElement
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=EString? 
	 *         direction=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         referencedProperties=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         composite=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedDefaultValue+=DataValue*
	 *     )
	 */
	protected void sequence_ExchangeItemElement(ISerializationContext context, ExchangeItemElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeItem returns ExchangeItem
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         exchangeMechanism=EString 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedElements+=ExchangeItemElement* 
	 *         ownedInformationRealizations+=InformationRealization*
	 *     )
	 */
	protected void sequence_ExchangeItem(ISerializationContext context, ExchangeItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeLink returns ExchangeLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchangeContainmentLinks=EString? 
	 *         sources=EString? 
	 *         destinations=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedExchangeContainments+=ExchangeContainment*
	 *     )
	 */
	protected void sequence_ExchangeLink(ISerializationContext context, ExchangeLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeSpecificationRealization returns ExchangeSpecificationRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeSpecificationRealization(ISerializationContext context, ExchangeSpecificationRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionRealization returns FunctionRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionRealization(ISerializationContext context, FunctionRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionSpecification returns FunctionSpecification
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedParameterSet=EString? 
	 *         ownedParameter=EString? 
	 *         inExchangeLinks=EString? 
	 *         outExchangeLinks=EString? 
	 *         isControlOperator=EString? 
	 *         isReadOnly=EString? 
	 *         isSingleExecution=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedNodes+=ActivityNode* 
	 *         ownedEdges+=ActivityEdge* 
	 *         ownedGroups+=ActivityGroup*
	 *     )
	 */
	protected void sequence_FunctionSpecification(ISerializationContext context, FunctionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalChainInvolvement returns FunctionalChainInvolvementLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         chainInvAppliedPropertyValues=EString? 
	 *         chainInvAppliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         chainInvFeatures=EString? 
	 *         involved=EString 
	 *         sourceReferenceHierarchy=EString? 
	 *         targetReferenceHierarchy=EString? 
	 *         exchangeContext=EString? 
	 *         exchangedItems=EString? 
	 *         source=EString? 
	 *         target=EString? 
	 *         chainInvOwnedPropertyValues+=AbstractPropertyValue? 
	 *         chainInvOwnedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         chainInvOwnedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionalChainInvolvement(ISerializationContext context, FunctionalChainInvolvementLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalChainRealization returns FunctionalChainRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionalChainRealization(ISerializationContext context, FunctionalChainRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalChain returns FunctionalChain
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         availableInStates=EString? 
	 *         preCondition=EString? 
	 *         postCondition=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedFunctionalChainInvolvements+=FunctionalChainInvolvement* 
	 *         ownedFunctionalChainRealizations+=FunctionalChainRealization* 
	 *         ownedSequenceNodes+=ControlNode* 
	 *         ownedSequenceLinks+=SequenceLink*
	 *     )
	 */
	protected void sequence_FunctionalChain(ISerializationContext context, FunctionalChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalExchangeRealization returns FunctionalExchangeRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionalExchangeRealization(ISerializationContext context, FunctionalExchangeRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalExchangeSpecification returns FunctionalExchangeSpecification
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         realizations=EString? 
	 *         convoyedInformations=EString? 
	 *         source=EString 
	 *         target=EString 
	 *         link=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_FunctionalExchangeSpecification(ISerializationContext context, FunctionalExchangeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalExchange returns FunctionalExchange
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=ID 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kindOfRate=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         target=EString 
	 *         source=EString 
	 *         interrupts=EString? 
	 *         transformation=EString? 
	 *         selection=EString? 
	 *         exchangeSpecifications=EString? 
	 *         exchangedItems=EString? 
	 *         isMulticast=EString? 
	 *         isMultireceive=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup? 
	 *         rate=ValueSpecification? 
	 *         probability=ValueSpecification? 
	 *         guard=ValueSpecification? 
	 *         weight=ValueSpecification? 
	 *         ownedFunctionalExchangeRealizations+=FunctionalExchangeRealization?
	 *     )
	 */
	protected void sequence_FunctionalExchange(ISerializationContext context, FunctionalExchange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Generalization returns Generalization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         super=EString 
	 *         sub=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_Generalization(ISerializationContext context, Generalization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InformationRealization returns InformationRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_InformationRealization(ISerializationContext context, InformationRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initialization returns Initialization
	 *
	 * Constraint:
	 *     name=nameType
	 */
	protected void sequence_Initialization(ISerializationContext context, Initialization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLADslPackage.eINSTANCE.getInitialization_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLADslPackage.eINSTANCE.getInitialization_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitializationAccess().getNameNameTypeParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputOutputPin returns FunctionInputPort
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         idType=EString? 
	 *         kindOfNode=EString? 
	 *         ordering=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         providedInterfaces=EString? 
	 *         requiredInterfaces=EString? 
	 *         abstractType=EString? 
	 *         representedComponentPort=EString? 
	 *         inState=EString? 
	 *         selection=EString? 
	 *         inputEvaluationAction=EString? 
	 *         incomingExchangeItems=EString? 
	 *         isControlType=EString? 
	 *         isControl=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedProtocols+=StateMachine* 
	 *         ownedPortRealizations+=PortRealization* 
	 *         ownedPortAllocations+=PortAllocation* 
	 *         upperBound=ValueSpecification?
	 *     )
	 */
	protected void sequence_InputOutputPin(ISerializationContext context, FunctionInputPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceAllocation returns InterfaceAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_InterfaceAllocation(ISerializationContext context, InterfaceAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceImplementation returns InterfaceImplementation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         implementedInterface=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_InterfaceImplementation(ISerializationContext context, InterfaceImplementation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfacePkg returns InterfacePkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedMessageReferences+=MessageReference* 
	 *         ownedExchangeItems+=ExchangeItem* 
	 *         ownedInterfaces+=Interface*
	 *     )
	 */
	protected void sequence_InterfacePkg(ISerializationContext context, InterfacePkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceUse returns InterfaceUse
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         usedInterface=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_InterfaceUse(ISerializationContext context, InterfaceUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Interface returns Interface
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         mechanism=EString? 
	 *         structural=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstract=EString? 
	 *         final=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedInterfaceAllocations+=InterfaceAllocation* 
	 *         ownedExchangeItemAllocations+=ExchangeItemAllocation*
	 *     )
	 */
	protected void sequence_Interface(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Invariant returns Invariant
	 *
	 * Constraint:
	 *     (leftPart=nameType rightPart=nameType)
	 */
	protected void sequence_Invariant(ISerializationContext context, Invariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLADslPackage.eINSTANCE.getInvariant_LeftPart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLADslPackage.eINSTANCE.getInvariant_LeftPart()));
			if (transientValues.isValueTransient(semanticObject, MyLADslPackage.eINSTANCE.getInvariant_RightPart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLADslPackage.eINSTANCE.getInvariant_RightPart()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantAccess().getLeftPartNameTypeParserRuleCall_1_0(), semanticObject.getLeftPart());
		feeder.accept(grammarAccess.getInvariantAccess().getRightPartNameTypeParserRuleCall_3_0(), semanticObject.getRightPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalArchitecture returns LogicalArchitecture
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         architectureId=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         containedLogicalFunctionPkg=LogicalFunctionPkg? 
	 *         ownedComponentExchanges+=ComponentExchange* 
	 *         ownedComponentExchangeCategories+=ComponentExchangeCategory* 
	 *         ownedFunctionalLinks+=ExchangeLink* 
	 *         ownedFunctionalAllocations+=ComponentFunctionalAllocation* 
	 *         ownedComponentExchangeRealizations+=ComponentExchangeRealization* 
	 *         ownedRequirementPkgs+=RequirementsPkg* 
	 *         ownedAbstractCapabilityPkg=AbstractCapabilityPkg? 
	 *         ownedInterfacePkg=InterfacePkg? 
	 *         ownedDataPkg=DataPkg? 
	 *         ownedLogicalComponentPkg=LogicalComponentPkg? 
	 *         ownedSystemAnalysisRealizations+=SystemAnalysisRealization*
	 *     )
	 */
	protected void sequence_LogicalArchitecture(ISerializationContext context, LogicalArchitecture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalComponentPkg returns LogicalComponentPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedParts+=Part* 
	 *         ownedComponentExchanges+=ComponentExchange* 
	 *         ownedComponentExchangeCategories+=ComponentExchangeCategory* 
	 *         ownedFunctionalLinks+=ExchangeLink* 
	 *         ownedFunctionalAllocations+=ComponentFunctionalAllocation* 
	 *         ownedComponentExchangeRealizations+=ComponentExchangeRealization* 
	 *         ownedPhysicalLinks+=PhysicalLink* 
	 *         ownedPhysicalLinkCategories+=PhysicalLinkCategory* 
	 *         ownedStateMachines+=StateMachine* 
	 *         ownedLogicalComponents+=LogicalComponent*
	 *     )
	 */
	protected void sequence_LogicalComponentPkg(ISerializationContext context, LogicalComponentPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalComponent returns LogicalComponent
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         idType=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         inExchangeLinks=EString? 
	 *         outExchangeLinks=EString? 
	 *         abstract=EString? 
	 *         actor=EString? 
	 *         human=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedContraints+=Constraint* 
	 *         ownedTraces+=Trace* 
	 *         ownedFunctionalAllocation+=ComponentFunctionalAllocation* 
	 *         ownedComponentExchanges+=ComponentExchange* 
	 *         ownedComponentExchangeCategories+=ComponentExchangeCategory* 
	 *         ownedStateMachines+=StateMachine* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedInterfaceAllocations+=InterfaceAllocation* 
	 *         ownedCommunicationLinks+=CommunicationLink* 
	 *         ownedInterfaceUses+=InterfaceUse* 
	 *         ownedInterfaceImplementations+=InterfaceImplementation* 
	 *         ownedComponentRealizations+=ComponentRealization* 
	 *         ownedPhysicalPath+=PhysicalPath* 
	 *         ownedPhysicalLinks+=PhysicalLink* 
	 *         ownedPhysicalLinkCategories+=PhysicalLinkCategory* 
	 *         ownedLogicalComponents+=LogicalComponent*
	 *     )
	 */
	protected void sequence_LogicalComponent(ISerializationContext context, LogicalComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalFunctionPkg returns LogicalFunctionPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedFunctionalLinks+=ExchangeLink* 
	 *         ownedExchanges+=FunctionalExchangeSpecification* 
	 *         ownedExchangeSpecificationRealizations+=ExchangeSpecificationRealization* 
	 *         ownedCategories+=ExchangeCategory* 
	 *         ownedFunctionSpecifications+=FunctionSpecification* 
	 *         ownedSystemFunctions+=LogicalFunction*
	 *     )
	 */
	protected void sequence_LogicalFunctionPkg(ISerializationContext context, LogicalFunctionPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalFunction returns LogicalFunction
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         aggregationKind=EString? 
	 *         idType=EString? 
	 *         kind=EString? 
	 *         condition=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         context=EString? 
	 *         behavior=EString? 
	 *         availableInStates=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedDataValue+=DataValue* 
	 *         ownedFunctionalChains+=FunctionalChain* 
	 *         ownedHandlers+=ExceptionHandler* 
	 *         inputsOutputsPin+=InputOutputPin* 
	 *         ownedFunctions+=AbstractFunction* 
	 *         ownedFunctionRealizations+=FunctionRealization* 
	 *         ownedFunctionalExchanges+=FunctionalExchange*
	 *     )
	 */
	protected void sequence_LogicalFunction(ISerializationContext context, LogicalFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageReference returns MessageReference
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         message=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_MessageReference(ISerializationContext context, MessageReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstract=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedStateMachines+=StateMachine*
	 *     )
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OpaqueExpression returns OpaqueExpression
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         nameSpecification=nameType? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         bodies=EString? 
	 *         languages=ID? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_OpaqueExpression(ISerializationContext context, OpaqueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Part returns Part
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         aggregationKind=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedValue+=DataValue* 
	 *         ownedDeploymentLinks+=AbstractDeploymentLink* 
	 *         ownedAbstractType=AbstractType?
	 *     )
	 */
	protected void sequence_Part(ISerializationContext context, Part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalLinkCategory returns PhysicalLinkCategory
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValue=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         links=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalLinkCategory(ISerializationContext context, PhysicalLinkCategory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalLinkEnd returns PhysicalLinkEnd
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         port=EString? 
	 *         part=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalLinkEnd(ISerializationContext context, PhysicalLinkEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalLinkRealization returns PhysicalLinkRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalLinkRealization(ISerializationContext context, PhysicalLinkRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalLink returns PhysicalLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         linkEnds=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedComponentExchangeAllocations+=ComponentExchangeAllocation* 
	 *         ownedComponentExchangeFunctionalExchangeAllocations+=ComponentExchangeFunctionalExchangeAllocation* 
	 *         ownedPhysicalLinkEnds+=PhysicalLinkEnd* 
	 *         ownedPhysicalLinkRealizations+=PhysicalLinkRealization*
	 *     )
	 */
	protected void sequence_PhysicalLink(ISerializationContext context, PhysicalLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalPathInvolvement returns PhysicalPathInvolvement
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         involved=EString 
	 *         nextInvolvements=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalPathInvolvement(ISerializationContext context, PhysicalPathInvolvement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalPathRealization returns PhysicalPathRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalPathRealization(ISerializationContext context, PhysicalPathRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalPath returns PhysicalPath
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         involvedLinks=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedComponentExchangeAllocations+=ComponentExchangeAllocation* 
	 *         ownedPhysicalPathInvolvements+=PhysicalPathInvolvement* 
	 *         ownedPhysicalPathRealizations+=PhysicalPathRealization*
	 *     )
	 */
	protected void sequence_PhysicalPath(ISerializationContext context, PhysicalPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortAllocation returns PortAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PortAllocation(ISerializationContext context, PortAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortRealization returns PortRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PortRealization(ISerializationContext context, PortRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyValueGroup returns PropertyValueGroup
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         statut=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace?
	 *     )
	 */
	protected void sequence_PropertyValueGroup(ISerializationContext context, PropertyValueGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyValuePkg returns PropertyValuePkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace? 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg*
	 *     )
	 */
	protected void sequence_PropertyValuePkg(ISerializationContext context, PropertyValuePkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Region returns Region
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         involvedStates=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTransitions+=StateTransition*
	 *     )
	 */
	protected void sequence_Region(ISerializationContext context, Region semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         requirementId=EString? 
	 *         additionalInformation=EString? 
	 *         verificationMethod=EString? 
	 *         verificationPhase=EString? 
	 *         implementationVersion=EString? 
	 *         feature=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         wnedTraces+=Trace*
	 *     )
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsPkg returns RequirementsPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         additionalInformation=EString? 
	 *         level=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedRequirements+=Requirement* 
	 *         ownedRequirementPkgs+=RequirementsPkg*
	 *     )
	 */
	protected void sequence_RequirementsPkg(ISerializationContext context, RequirementsPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SequenceLink returns SequenceLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         sourceReferenceHierarchy=EString? 
	 *         targetReferenceHierarchy=EString? 
	 *         condition=EString? 
	 *         links=EString? 
	 *         source=EString? 
	 *         target=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_SequenceLink(ISerializationContext context, SequenceLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateMachine returns StateMachine
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedParameterSet=EString? 
	 *         ownedParameter=EString? 
	 *         isControlOperator?='isControlOperator'? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedRegions+=Region*
	 *     )
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateTransitionRealization returns StateTransitionRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_StateTransitionRealization(ISerializationContext context, StateTransitionRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateTransition returns StateTransition
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=EString? 
	 *         triggerDescription=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         guard=EString? 
	 *         source=EString 
	 *         target=EString 
	 *         effect=EString? 
	 *         triggers=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedStateTransitionRealizations+=StateTransitionRealization*
	 *     )
	 */
	protected void sequence_StateTransition(ISerializationContext context, StateTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SystemAnalysisRealization returns SystemAnalysisRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_SystemAnalysisRealization(ISerializationContext context, SystemAnalysisRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trace returns Trace
	 *
	 * Constraint:
	 *     (
	 *         typeTrace=EString 
	 *         idTrace=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizFlow=EString? 
	 *         appliedPropertyValues=[AbstractPropertyValue|EString]? 
	 *         appliedPropertyValueGroups=[PropertyValueGroup|EString]? 
	 *         statut=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_Trace(ISerializationContext context, Trace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueSpecification returns ValueSpecification
	 *
	 * Constraint:
	 *     (type=EString id=EString sid=EString? name=nameType? abstractType=EString?)
	 */
	protected void sequence_ValueSpecification(ISerializationContext context, ValueSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataValue returns ValueTag
	 *     ValueTag returns ValueTag
	 *
	 * Constraint:
	 *     (
	 *         objectType=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         (nameValue=nameType | nameValue=EmptyString)? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         referencedValue=EString? 
	 *         referencedProperty=EString? 
	 *         unit=EString? 
	 *         boolValAbstract=EString? 
	 *         value=EString? 
	 *         ooperator=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         domainValue+=DataValue*
	 *     )
	 */
	protected void sequence_ValueTag(ISerializationContext context, ValueTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
