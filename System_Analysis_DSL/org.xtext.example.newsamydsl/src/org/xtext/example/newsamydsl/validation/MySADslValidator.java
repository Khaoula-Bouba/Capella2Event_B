/*
 * generated by Xtext 2.22.0
 */
package org.xtext.example.newsamydsl.validation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.mydsl.mySADsl.AbstractFunction;
import org.xtext.example.mydsl.mySADsl.Constraint;
import org.xtext.example.mydsl.mySADsl.FunctionalExchange;
import org.xtext.example.mydsl.mySADsl.Initialization;
import org.xtext.example.mydsl.mySADsl.Invariant;
import org.xtext.example.mydsl.mySADsl.SystemAnalysis;
import org.xtext.example.mydsl.mySADsl.SystemComponent;
import org.xtext.example.mydsl.mySADsl.SystemComponentPkg;
import org.xtext.example.mydsl.mySADsl.SystemFunction;
import org.xtext.example.mydsl.validation.AbstractMySADslValidator;


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MySADslValidator extends AbstractMySADslValidator {
	
	@Check
	public void checkSASyntax(SystemAnalysis architecture, List<String> errors) {
		
		
		EList<SystemFunction> sysFunctions = architecture.getOwnedFunctionPkg().getOwnedSystemFunctions();
		EList<AbstractFunction> functions = sysFunctions.get(0).getOwnedFunctions();
		
		SystemComponentPkg SystemComponentPkg = architecture.getOwnedSystemComponentPkg();
		
		List<String> functions2 = new ArrayList<>();
		List<String> sysComponents2 = new ArrayList<>();	
		List<String> exchangeValues = getFunctionalExchanges(sysFunctions.get(0));
		List<String> valuesToAddFronInit = new ArrayList<>();
		List<String> constValuesList = new ArrayList<>();
		
		EList<SystemComponent> sysComponents = SystemComponentPkg.getOwnedSystemComponents();
		
		//Check that the functions don't have the same name
		for(AbstractFunction function : functions) {
			EList<Constraint> constraintsObjs = function.getOwnedConstraints();
			
			getAllInitializations(constraintsObjs, exchangeValues, valuesToAddFronInit, constValuesList, true);
			
			String functionNameValue = function.getName();
			checkNames(functions2, functionNameValue, "function", function, errors);
		}
		
		
		//Check that the system components don't have the same name
		for(SystemComponent sysComponent : sysComponents) {
			parseSysComponents(sysComponent, exchangeValues, valuesToAddFronInit, constValuesList, errors, sysComponents2);
		}
		
		exchangeValues.addAll(valuesToAddFronInit);
		
		parseConstraints(constValuesList, errors, exchangeValues);
	}
	
	//parse the system component and check the uniqueness of its name
	public void parseSysComponents(SystemComponent sysComponent, List<String> exchangeValues, List<String> valuesToAddFronInit,
			List<String> constValuesList, List<String> errors, List<String> sysComponents2) {
		EList<Constraint> constraintsObjs = sysComponent.getOwnedContraints();
		
        getAllInitializations(constraintsObjs, exchangeValues, valuesToAddFronInit, constValuesList, false);
		
		String sysCompNameValue = sysComponent.getName();
		checkNames(sysComponents2, sysCompNameValue, "system component", sysComponent, errors);
		
		EList<SystemComponent> subSysComponents = sysComponent.getOwnedSystemComponents();
		for(SystemComponent subSysComponent : subSysComponents) {
			parseSysComponents(subSysComponent, exchangeValues, valuesToAddFronInit, constValuesList, errors, sysComponents2);
		}
	}
	
    //get the list of the functional exchanges values     
    public List<String> getFunctionalExchanges(SystemFunction sysFunction){
    	List<String> exchangesValues = new ArrayList<>();
    	// Find the corresponding FunctionalExchange elements
        EList<FunctionalExchange> functionalExchanges = new BasicEList<>();
        functionalExchanges.addAll(sysFunction.getOwnedFunctionalExchanges());
        for (FunctionalExchange exchange : functionalExchanges) {
            exchangesValues.add(exchange.getName());
        }
        return exchangesValues;
    }
    
    // chech the uniqueness of the name value
	public void checkNames(List<String> listOfNames, String value, String msg, EObject object, List<String> errors) {
		if (listOfNames.contains(value)) {
			errors.add("The name of the " + msg +" \""+ value +"\" exists already, please change it.");
		} else {
			listOfNames.add(value);
		}
	}
    
    public static boolean checkConstraintSyntax(String constValue, List<String> errors, List<String> exchangeValues) {
    	
		List<String> filteredElements = Arrays.stream(constValue.split(" "))
				// Replace parentheses, &amp;, and or
				.map(element -> element.replace("(", "").replace(")", ""))
				.filter(element -> !element.equals("(") && !element.equals(")") && !element.equals("&amp;")
						&& !element.equals("or"))
				// Split elements by "not()" pattern and flatten the resulting stream
				.flatMap(element -> {
					if (element.startsWith("not(")) {
						return Arrays.stream(new String[] { element.substring(4, element.length() - 1) });
					} else if (element.startsWith("not")) {
						return Arrays.stream(new String[] { element.substring(3) });
					}
					return Arrays.stream(new String[] { element });
				}).filter(element -> !element.isEmpty()).collect(Collectors.toList());

		boolean isCorrectConst = filteredElements.stream().allMatch(element -> exchangeValues.contains(element));
		boolean constValid = true;
		
		if (!isCorrectConst && errors != null) {
			errors.add("The Constraint { " + constValue
					+ " } must be composed of names from FunctionalExchange elements.");
		} else {
			constValid = isValidExpression(constValue);
			if (!constValid && errors != null) {
				errors.add("The semantic of the constraint { " + constValue + " } is incorrect.");
			}
		}
		
		return isCorrectConst && constValid;
    }
    
    public static boolean isAnOperator(char c) {
	    switch (c) {
	        case '&':
	        case 'o':
	            return true;
	        default:
	            return false;
	    }
	}

	public static boolean isValidExpression(String expression) {
		
	    int openParenthCount = 0;
	    boolean lastWasOp = false;
	    boolean lastWasOpen = false;

	    StringBuilder modifiedExpression = new StringBuilder();
        
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
	        if (c == ' ') {
	        	continue;
	        }

	        if (c == '(') {
	            openParenthCount++;
	            lastWasOpen = true;
	            modifiedExpression.append(c);
	            continue;
	        } else if (c == ')') {
	            if (openParenthCount <= 0 || lastWasOp) {
	                return false;
	            }
	            openParenthCount--;
	            modifiedExpression.append(c);
	        } else if (isAnOperator(c)) {
	            if (lastWasOp || lastWasOpen) return false;

	            if (c == '&') {
	            	if (i + 4 < expression.length() && expression.substring(i, i + 5).equalsIgnoreCase("&amp;")) {
	                    i += 4; // Skip the next three characters as they are part of '&amp;'
	                } else {
	                    return false; // Invalid '&amp;' operator
	                }
	            	
	                //modifiedExpression.append("&amp;");
				} else if (c == 'o') {
					if (expression.charAt(i - 1) == ' ' && i + 1 < expression.length()
							&& (expression.charAt(i + 1) == 'r' || expression.charAt(i + 1) == 'R')) {
						
						i++; // Skip the next character as it is part of 'or'
					}
				}

	            lastWasOp = true;
	            continue;
	        }

	        lastWasOp = false;
	        lastWasOpen = false;
	    }

	    if (openParenthCount != 0) return false;
	    if (lastWasOp || lastWasOpen) return false;

	    return true;
	}
    
	// Parse the constraints to check if it's intialization or invarinat, if it's the case, then verify the syntax
	public static void parseConstraints(List<String> constValuesList, List<String> errors, List<String> exchangeValues) {
		for (String constValue : constValuesList) {

			// syntax check for the initialization
			if (constValue.startsWith("=")) {
				List<String> initializationElements = Arrays.stream(constValue.split(" "))
						.map(element -> element.replace(" ", "")).collect(Collectors.toList());
				initializationElements.remove(0);
				boolean isCorrectInitialization = initializationElements.size() == 1
						&& initializationElements.stream().allMatch(element -> exchangeValues.contains(element));
				if (!isCorrectInitialization) {
					errors.add("This initialization " + constValue + " is not correct.");
				}
			} else if (constValue.startsWith(":")) {
				String[] left_right_parts = constValue.split("\\s*>>\\s*");
				
				String leftPartStr = left_right_parts[0].substring(1);
		        String rightPartStr = Arrays.stream(left_right_parts)
					                        .skip(1).map(String::trim).findFirst()
					                        .orElse("");

				if (leftPartStr != null && rightPartStr == null) {
					String originalLeftPartStr = leftPartStr.replace("&amp;", "&");
					errors.add("The constraint " + originalLeftPartStr + " is not correct. The character >> is missing.");
				} else if (leftPartStr == null && rightPartStr != null) {
					String originalRightPartStr = rightPartStr.replace("&amp;", "&");
					errors.add("The constraint " + originalRightPartStr + " is not correct. The character >> is missing.");
				} else if (leftPartStr != null && rightPartStr != null) {
					boolean isLeftPartValid = checkConstraintSyntax(leftPartStr, null, exchangeValues);
					boolean isRightPartValid = checkConstraintSyntax(rightPartStr, null, exchangeValues);

					if (!isLeftPartValid || !isRightPartValid) {
						errors.add("The constraint " + leftPartStr.replace("&amp;", "&") + " >> " + rightPartStr.replace("&amp;", "&") + " is incorrect.");
					}
				}
			} else {
				checkConstraintSyntax(constValue, errors, exchangeValues);
			}
		}
	}
	
	// get the list of all the intialization values (constraints that start with "=")
    public static void getAllInitializations(EList<Constraint> constraintsObjs, List<String> exchangeValues, List<String> valuesToAddFronInit,
    		List<String> constValuesList, boolean isFunction) {
    	
		for (Constraint constrObj : constraintsObjs) {

			EObject constImplObject = constrObj.getName();
			String constValue = "";

			if (constImplObject instanceof Initialization) {
				String constraintValue = ((Initialization) constImplObject).getName();
				if(isFunction) {
					constValuesList.add(constraintValue);
				}else{
					valuesToAddFronInit.add(constraintValue);
					constValue = "= ".concat(constraintValue);
					constValuesList.add(constValue);
				}
				
			} else if (constImplObject instanceof Invariant) {
				if(((Invariant) constImplObject).getLeftPart() != null && ((Invariant) constImplObject).getRightPart() == null) {
					constValue = ":".concat(((Invariant) constImplObject).getLeftPart()).concat(">>").concat("");
				}else if(((Invariant) constImplObject).getLeftPart() == null && ((Invariant) constImplObject).getRightPart() != null) {
					constValue = ":".concat("").concat(">>").concat(((Invariant) constImplObject).getRightPart());
				}else {
					constValue = ":".concat(((Invariant) constImplObject).getLeftPart()).concat(">>").concat(((Invariant) constImplObject).getRightPart());
				}
				
				constValuesList.add(constValue);		
			}
		}
    }
	
}
