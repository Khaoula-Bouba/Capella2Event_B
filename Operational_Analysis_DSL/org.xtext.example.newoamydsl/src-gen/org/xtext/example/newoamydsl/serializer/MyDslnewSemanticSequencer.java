/*
 * generated by Xtext 2.22.0
 */
package org.xtext.example.newoamydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.newoamydsl.myDslnew.AbstractDeploymentLink;
import org.xtext.example.newoamydsl.myDslnew.AbstractFunction;
import org.xtext.example.newoamydsl.myDslnew.AbstractPropertyValue;
import org.xtext.example.newoamydsl.myDslnew.AbstractType;
import org.xtext.example.newoamydsl.myDslnew.ActivityAllocation;
import org.xtext.example.newoamydsl.myDslnew.ActivityEdge;
import org.xtext.example.newoamydsl.myDslnew.ActivityGroup;
import org.xtext.example.newoamydsl.myDslnew.ActivityNode;
import org.xtext.example.newoamydsl.myDslnew.Association;
import org.xtext.example.newoamydsl.myDslnew.CapabilityConfiguration;
import org.xtext.example.newoamydsl.myDslnew.Collection;
import org.xtext.example.newoamydsl.myDslnew.CommunicationLink;
import org.xtext.example.newoamydsl.myDslnew.CommunicationMean;
import org.xtext.example.newoamydsl.myDslnew.ComponentExchange;
import org.xtext.example.newoamydsl.myDslnew.ComponentExchangeAllocation;
import org.xtext.example.newoamydsl.myDslnew.ComponentExchangeCategory;
import org.xtext.example.newoamydsl.myDslnew.ComponentExchangeEnd;
import org.xtext.example.newoamydsl.myDslnew.ComponentExchangeFunctionalExchangeAllocation;
import org.xtext.example.newoamydsl.myDslnew.ComponentExchangeRealization;
import org.xtext.example.newoamydsl.myDslnew.ComponentFunctionalAllocation;
import org.xtext.example.newoamydsl.myDslnew.ComponentRealization;
import org.xtext.example.newoamydsl.myDslnew.Concept;
import org.xtext.example.newoamydsl.myDslnew.ConceptCompliance;
import org.xtext.example.newoamydsl.myDslnew.ConceptPkg;
import org.xtext.example.newoamydsl.myDslnew.Constraint;
import org.xtext.example.newoamydsl.myDslnew.ControlNode;
import org.xtext.example.newoamydsl.myDslnew.DataPkg;
import org.xtext.example.newoamydsl.myDslnew.DataType;
import org.xtext.example.newoamydsl.myDslnew.Entity;
import org.xtext.example.newoamydsl.myDslnew.EntityOperationalCapabilityInvolvement;
import org.xtext.example.newoamydsl.myDslnew.EntityPkg;
import org.xtext.example.newoamydsl.myDslnew.EnumerationPropertyLiteral;
import org.xtext.example.newoamydsl.myDslnew.EnumerationPropertyType;
import org.xtext.example.newoamydsl.myDslnew.ExceptionHandler;
import org.xtext.example.newoamydsl.myDslnew.ExchangeCategory;
import org.xtext.example.newoamydsl.myDslnew.ExchangeContainment;
import org.xtext.example.newoamydsl.myDslnew.ExchangeItem;
import org.xtext.example.newoamydsl.myDslnew.ExchangeItemAllocation;
import org.xtext.example.newoamydsl.myDslnew.ExchangeItemElement;
import org.xtext.example.newoamydsl.myDslnew.ExchangeItemInstance;
import org.xtext.example.newoamydsl.myDslnew.ExchangeLink;
import org.xtext.example.newoamydsl.myDslnew.Feature;
import org.xtext.example.newoamydsl.myDslnew.FunctionPkg;
import org.xtext.example.newoamydsl.myDslnew.FunctionRealization;
import org.xtext.example.newoamydsl.myDslnew.FunctionSpecification;
import org.xtext.example.newoamydsl.myDslnew.FunctionalChain;
import org.xtext.example.newoamydsl.myDslnew.FunctionalChainInvolvementLink;
import org.xtext.example.newoamydsl.myDslnew.FunctionalChainRealization;
import org.xtext.example.newoamydsl.myDslnew.FunctionalExchange;
import org.xtext.example.newoamydsl.myDslnew.FunctionalExchangeRealization;
import org.xtext.example.newoamydsl.myDslnew.FunctionalExchangeSpecification;
import org.xtext.example.newoamydsl.myDslnew.GeneralClass;
import org.xtext.example.newoamydsl.myDslnew.Generalization;
import org.xtext.example.newoamydsl.myDslnew.InformationRealization;
import org.xtext.example.newoamydsl.myDslnew.Initialization;
import org.xtext.example.newoamydsl.myDslnew.InputOutputPin;
import org.xtext.example.newoamydsl.myDslnew.Interface;
import org.xtext.example.newoamydsl.myDslnew.InterfaceAllocation;
import org.xtext.example.newoamydsl.myDslnew.InterfaceImplementation;
import org.xtext.example.newoamydsl.myDslnew.InterfacePkg;
import org.xtext.example.newoamydsl.myDslnew.InterfaceUse;
import org.xtext.example.newoamydsl.myDslnew.Invariant;
import org.xtext.example.newoamydsl.myDslnew.ItemInConcept;
import org.xtext.example.newoamydsl.myDslnew.KeyPart;
import org.xtext.example.newoamydsl.myDslnew.Location;
import org.xtext.example.newoamydsl.myDslnew.Message;
import org.xtext.example.newoamydsl.myDslnew.MessageReference;
import org.xtext.example.newoamydsl.myDslnew.MyDslnewPackage;
import org.xtext.example.newoamydsl.myDslnew.OpaqueExpression;
import org.xtext.example.newoamydsl.myDslnew.OperationalActivity;
import org.xtext.example.newoamydsl.myDslnew.OperationalActivityPkg;
import org.xtext.example.newoamydsl.myDslnew.OperationalCapability;
import org.xtext.example.newoamydsl.myDslnew.OperationalCapabilityPkg;
import org.xtext.example.newoamydsl.myDslnew.Part;
import org.xtext.example.newoamydsl.myDslnew.PhysicalLink;
import org.xtext.example.newoamydsl.myDslnew.PhysicalLinkEnd;
import org.xtext.example.newoamydsl.myDslnew.PhysicalLinkRealization;
import org.xtext.example.newoamydsl.myDslnew.PhysicalPath;
import org.xtext.example.newoamydsl.myDslnew.PhysicalPathInvolvement;
import org.xtext.example.newoamydsl.myDslnew.PropertyValueGroup;
import org.xtext.example.newoamydsl.myDslnew.PropertyValuePkg;
import org.xtext.example.newoamydsl.myDslnew.Region;
import org.xtext.example.newoamydsl.myDslnew.Requirement;
import org.xtext.example.newoamydsl.myDslnew.RequirementsPkg;
import org.xtext.example.newoamydsl.myDslnew.Role;
import org.xtext.example.newoamydsl.myDslnew.RoleAllocation;
import org.xtext.example.newoamydsl.myDslnew.RoleAssemblyUsage;
import org.xtext.example.newoamydsl.myDslnew.RolePkg;
import org.xtext.example.newoamydsl.myDslnew.SequenceLink;
import org.xtext.example.newoamydsl.myDslnew.Signal;
import org.xtext.example.newoamydsl.myDslnew.SignalInstance;
import org.xtext.example.newoamydsl.myDslnew.StateEvent;
import org.xtext.example.newoamydsl.myDslnew.StateEventRealization;
import org.xtext.example.newoamydsl.myDslnew.StateMachine;
import org.xtext.example.newoamydsl.myDslnew.StateTransition;
import org.xtext.example.newoamydsl.myDslnew.StateTransitionRealization;
import org.xtext.example.newoamydsl.myDslnew.Trace;
import org.xtext.example.newoamydsl.myDslnew.Unit;
import org.xtext.example.newoamydsl.myDslnew.ValueSpecification;
import org.xtext.example.newoamydsl.myDslnew.ValueTag;
import org.xtext.example.newoamydsl.myDslnew.operationalAnalysis;
import org.xtext.example.newoamydsl.services.MyDslnewGrammarAccess;

@SuppressWarnings("all")
public class MyDslnewSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslnewGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslnewPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslnewPackage.ABSTRACT_DEPLOYMENT_LINK:
				sequence_AbstractDeploymentLink(context, (AbstractDeploymentLink) semanticObject); 
				return; 
			case MyDslnewPackage.ABSTRACT_FUNCTION:
				sequence_AbstractFunction(context, (AbstractFunction) semanticObject); 
				return; 
			case MyDslnewPackage.ABSTRACT_PROPERTY_VALUE:
				sequence_AbstractPropertyValue(context, (AbstractPropertyValue) semanticObject); 
				return; 
			case MyDslnewPackage.ABSTRACT_TYPE:
				sequence_AbstractType(context, (AbstractType) semanticObject); 
				return; 
			case MyDslnewPackage.ACTIVITY_ALLOCATION:
				sequence_ActivityAllocation(context, (ActivityAllocation) semanticObject); 
				return; 
			case MyDslnewPackage.ACTIVITY_EDGE:
				sequence_ActivityEdge(context, (ActivityEdge) semanticObject); 
				return; 
			case MyDslnewPackage.ACTIVITY_GROUP:
				sequence_ActivityGroup(context, (ActivityGroup) semanticObject); 
				return; 
			case MyDslnewPackage.ACTIVITY_NODE:
				sequence_ActivityNode(context, (ActivityNode) semanticObject); 
				return; 
			case MyDslnewPackage.ASSOCIATION:
				sequence_Association(context, (Association) semanticObject); 
				return; 
			case MyDslnewPackage.CAPABILITY_CONFIGURATION:
				sequence_CapabilityConfiguration(context, (CapabilityConfiguration) semanticObject); 
				return; 
			case MyDslnewPackage.CLASS:
				sequence_Class(context, (org.xtext.example.newoamydsl.myDslnew.Class) semanticObject); 
				return; 
			case MyDslnewPackage.COLLECTION:
				sequence_Collection(context, (Collection) semanticObject); 
				return; 
			case MyDslnewPackage.COMMUNICATION_LINK:
				sequence_CommunicationLink(context, (CommunicationLink) semanticObject); 
				return; 
			case MyDslnewPackage.COMMUNICATION_MEAN:
				sequence_CommunicationMean(context, (CommunicationMean) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_EXCHANGE:
				sequence_ComponentExchange(context, (ComponentExchange) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_EXCHANGE_ALLOCATION:
				sequence_ComponentExchangeAllocation(context, (ComponentExchangeAllocation) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_EXCHANGE_CATEGORY:
				sequence_ComponentExchangeCategory(context, (ComponentExchangeCategory) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_EXCHANGE_END:
				sequence_ComponentExchangeEnd(context, (ComponentExchangeEnd) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_EXCHANGE_FUNCTIONAL_EXCHANGE_ALLOCATION:
				sequence_ComponentExchangeFunctionalExchangeAllocation(context, (ComponentExchangeFunctionalExchangeAllocation) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_EXCHANGE_REALIZATION:
				sequence_ComponentExchangeRealization(context, (ComponentExchangeRealization) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_FUNCTIONAL_ALLOCATION:
				sequence_ComponentFunctionalAllocation(context, (ComponentFunctionalAllocation) semanticObject); 
				return; 
			case MyDslnewPackage.COMPONENT_REALIZATION:
				sequence_ComponentRealization(context, (ComponentRealization) semanticObject); 
				return; 
			case MyDslnewPackage.CONCEPT:
				sequence_Concept(context, (Concept) semanticObject); 
				return; 
			case MyDslnewPackage.CONCEPT_COMPLIANCE:
				sequence_ConceptCompliance(context, (ConceptCompliance) semanticObject); 
				return; 
			case MyDslnewPackage.CONCEPT_PKG:
				sequence_ConceptPkg(context, (ConceptPkg) semanticObject); 
				return; 
			case MyDslnewPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case MyDslnewPackage.CONTROL_NODE:
				sequence_ControlNode(context, (ControlNode) semanticObject); 
				return; 
			case MyDslnewPackage.DATA_PKG:
				sequence_DataPkg(context, (DataPkg) semanticObject); 
				return; 
			case MyDslnewPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case MyDslnewPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case MyDslnewPackage.ENTITY_OPERATIONAL_CAPABILITY_INVOLVEMENT:
				sequence_EntityOperationalCapabilityInvolvement(context, (EntityOperationalCapabilityInvolvement) semanticObject); 
				return; 
			case MyDslnewPackage.ENTITY_PKG:
				sequence_EntityPkg(context, (EntityPkg) semanticObject); 
				return; 
			case MyDslnewPackage.ENUMERATION_PROPERTY_LITERAL:
				sequence_EnumerationPropertyLiteral(context, (EnumerationPropertyLiteral) semanticObject); 
				return; 
			case MyDslnewPackage.ENUMERATION_PROPERTY_TYPE:
				sequence_EnumerationPropertyType(context, (EnumerationPropertyType) semanticObject); 
				return; 
			case MyDslnewPackage.EXCEPTION:
				sequence_Exception(context, (org.xtext.example.newoamydsl.myDslnew.Exception) semanticObject); 
				return; 
			case MyDslnewPackage.EXCEPTION_HANDLER:
				sequence_ExceptionHandler(context, (ExceptionHandler) semanticObject); 
				return; 
			case MyDslnewPackage.EXCHANGE_CATEGORY:
				sequence_ExchangeCategory(context, (ExchangeCategory) semanticObject); 
				return; 
			case MyDslnewPackage.EXCHANGE_CONTAINMENT:
				sequence_ExchangeContainment(context, (ExchangeContainment) semanticObject); 
				return; 
			case MyDslnewPackage.EXCHANGE_ITEM:
				sequence_ExchangeItem(context, (ExchangeItem) semanticObject); 
				return; 
			case MyDslnewPackage.EXCHANGE_ITEM_ALLOCATION:
				sequence_ExchangeItemAllocation(context, (ExchangeItemAllocation) semanticObject); 
				return; 
			case MyDslnewPackage.EXCHANGE_ITEM_ELEMENT:
				sequence_ExchangeItemElement(context, (ExchangeItemElement) semanticObject); 
				return; 
			case MyDslnewPackage.EXCHANGE_ITEM_INSTANCE:
				sequence_ExchangeItemInstance(context, (ExchangeItemInstance) semanticObject); 
				return; 
			case MyDslnewPackage.EXCHANGE_LINK:
				sequence_ExchangeLink(context, (ExchangeLink) semanticObject); 
				return; 
			case MyDslnewPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTION_PKG:
				sequence_FunctionPkg(context, (FunctionPkg) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTION_REALIZATION:
				sequence_FunctionRealization(context, (FunctionRealization) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTION_SPECIFICATION:
				sequence_FunctionSpecification(context, (FunctionSpecification) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTIONAL_CHAIN:
				sequence_FunctionalChain(context, (FunctionalChain) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTIONAL_CHAIN_INVOLVEMENT_LINK:
				sequence_FunctionalChainInvolvement(context, (FunctionalChainInvolvementLink) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTIONAL_CHAIN_REALIZATION:
				sequence_FunctionalChainRealization(context, (FunctionalChainRealization) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTIONAL_EXCHANGE:
				sequence_FunctionalExchange(context, (FunctionalExchange) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTIONAL_EXCHANGE_REALIZATION:
				sequence_FunctionalExchangeRealization(context, (FunctionalExchangeRealization) semanticObject); 
				return; 
			case MyDslnewPackage.FUNCTIONAL_EXCHANGE_SPECIFICATION:
				sequence_FunctionalExchangeSpecification(context, (FunctionalExchangeSpecification) semanticObject); 
				return; 
			case MyDslnewPackage.GENERAL_CLASS:
				sequence_GeneralClass(context, (GeneralClass) semanticObject); 
				return; 
			case MyDslnewPackage.GENERALIZATION:
				sequence_Generalization(context, (Generalization) semanticObject); 
				return; 
			case MyDslnewPackage.INFORMATION_REALIZATION:
				sequence_InformationRealization(context, (InformationRealization) semanticObject); 
				return; 
			case MyDslnewPackage.INITIALIZATION:
				sequence_Initialization(context, (Initialization) semanticObject); 
				return; 
			case MyDslnewPackage.INPUT_OUTPUT_PIN:
				sequence_InputOutputPin(context, (InputOutputPin) semanticObject); 
				return; 
			case MyDslnewPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case MyDslnewPackage.INTERFACE_ALLOCATION:
				sequence_InterfaceAllocation(context, (InterfaceAllocation) semanticObject); 
				return; 
			case MyDslnewPackage.INTERFACE_IMPLEMENTATION:
				sequence_InterfaceImplementation(context, (InterfaceImplementation) semanticObject); 
				return; 
			case MyDslnewPackage.INTERFACE_PKG:
				sequence_InterfacePkg(context, (InterfacePkg) semanticObject); 
				return; 
			case MyDslnewPackage.INTERFACE_USE:
				sequence_InterfaceUse(context, (InterfaceUse) semanticObject); 
				return; 
			case MyDslnewPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case MyDslnewPackage.ITEM_IN_CONCEPT:
				sequence_ItemInConcept(context, (ItemInConcept) semanticObject); 
				return; 
			case MyDslnewPackage.KEY_PART:
				sequence_KeyPart(context, (KeyPart) semanticObject); 
				return; 
			case MyDslnewPackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case MyDslnewPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case MyDslnewPackage.MESSAGE_REFERENCE:
				sequence_MessageReference(context, (MessageReference) semanticObject); 
				return; 
			case MyDslnewPackage.OPAQUE_EXPRESSION:
				sequence_OpaqueExpression(context, (OpaqueExpression) semanticObject); 
				return; 
			case MyDslnewPackage.OPERATIONAL_ACTIVITY:
				sequence_OperationalActivity(context, (OperationalActivity) semanticObject); 
				return; 
			case MyDslnewPackage.OPERATIONAL_ACTIVITY_PKG:
				sequence_OperationalActivityPkg(context, (OperationalActivityPkg) semanticObject); 
				return; 
			case MyDslnewPackage.OPERATIONAL_CAPABILITY:
				sequence_OperationalCapability(context, (OperationalCapability) semanticObject); 
				return; 
			case MyDslnewPackage.OPERATIONAL_CAPABILITY_PKG:
				sequence_OperationalCapabilityPkg(context, (OperationalCapabilityPkg) semanticObject); 
				return; 
			case MyDslnewPackage.PART:
				sequence_Part(context, (Part) semanticObject); 
				return; 
			case MyDslnewPackage.PHYSICAL_LINK:
				sequence_PhysicalLink(context, (PhysicalLink) semanticObject); 
				return; 
			case MyDslnewPackage.PHYSICAL_LINK_END:
				sequence_PhysicalLinkEnd(context, (PhysicalLinkEnd) semanticObject); 
				return; 
			case MyDslnewPackage.PHYSICAL_LINK_REALIZATION:
				sequence_PhysicalLinkRealization(context, (PhysicalLinkRealization) semanticObject); 
				return; 
			case MyDslnewPackage.PHYSICAL_PATH:
				sequence_PhysicalPath(context, (PhysicalPath) semanticObject); 
				return; 
			case MyDslnewPackage.PHYSICAL_PATH_INVOLVEMENT:
				sequence_PhysicalPathInvolvement(context, (PhysicalPathInvolvement) semanticObject); 
				return; 
			case MyDslnewPackage.PROPERTY_VALUE_GROUP:
				sequence_PropertyValueGroup(context, (PropertyValueGroup) semanticObject); 
				return; 
			case MyDslnewPackage.PROPERTY_VALUE_PKG:
				sequence_PropertyValuePkg(context, (PropertyValuePkg) semanticObject); 
				return; 
			case MyDslnewPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case MyDslnewPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case MyDslnewPackage.REQUIREMENTS_PKG:
				sequence_RequirementsPkg(context, (RequirementsPkg) semanticObject); 
				return; 
			case MyDslnewPackage.ROLE:
				sequence_Role(context, (Role) semanticObject); 
				return; 
			case MyDslnewPackage.ROLE_ALLOCATION:
				sequence_RoleAllocation(context, (RoleAllocation) semanticObject); 
				return; 
			case MyDslnewPackage.ROLE_ASSEMBLY_USAGE:
				sequence_RoleAssemblyUsage(context, (RoleAssemblyUsage) semanticObject); 
				return; 
			case MyDslnewPackage.ROLE_PKG:
				sequence_RolePkg(context, (RolePkg) semanticObject); 
				return; 
			case MyDslnewPackage.SEQUENCE_LINK:
				sequence_SequenceLink(context, (SequenceLink) semanticObject); 
				return; 
			case MyDslnewPackage.SIGNAL:
				sequence_Signal(context, (Signal) semanticObject); 
				return; 
			case MyDslnewPackage.SIGNAL_INSTANCE:
				sequence_SignalInstance(context, (SignalInstance) semanticObject); 
				return; 
			case MyDslnewPackage.STATE_EVENT:
				sequence_StateEvent(context, (StateEvent) semanticObject); 
				return; 
			case MyDslnewPackage.STATE_EVENT_REALIZATION:
				sequence_StateEventRealization(context, (StateEventRealization) semanticObject); 
				return; 
			case MyDslnewPackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case MyDslnewPackage.STATE_TRANSITION:
				sequence_StateTransition(context, (StateTransition) semanticObject); 
				return; 
			case MyDslnewPackage.STATE_TRANSITION_REALIZATION:
				sequence_StateTransitionRealization(context, (StateTransitionRealization) semanticObject); 
				return; 
			case MyDslnewPackage.TRACE:
				sequence_Trace(context, (Trace) semanticObject); 
				return; 
			case MyDslnewPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case MyDslnewPackage.VALUE_SPECIFICATION:
				sequence_ValueSpecification(context, (ValueSpecification) semanticObject); 
				return; 
			case MyDslnewPackage.VALUE_TAG:
				sequence_ValueTag(context, (ValueTag) semanticObject); 
				return; 
			case MyDslnewPackage.OPERATIONAL_ANALYSIS:
				sequence_operationalAnalysis(context, (operationalAnalysis) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractDeploymentLink returns AbstractDeploymentLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         deployedElement=EString 
	 *         location=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_AbstractDeploymentLink(ISerializationContext context, AbstractDeploymentLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractFunction returns AbstractFunction
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         aggregationKind=AggregationKind? 
	 *         idType=EString? 
	 *         kind=FunctionKind? 
	 *         condition=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         context=EString? 
	 *         behavior=EString? 
	 *         availableInStates=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusiv=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedDefaultValue+=DataValue* 
	 *         ownedFunctionalChains+=FunctionalChain* 
	 *         ownedHandlers+=ExceptionHandler* 
	 *         inoutsOutputs+=InputOutputPin* 
	 *         ownedFunctionRealizations+=FunctionRealization* 
	 *         ownedConstraints+=Constraint*
	 *     )
	 */
	protected void sequence_AbstractFunction(ISerializationContext context, AbstractFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractPropertyValue returns AbstractPropertyValue
	 *
	 * Constraint:
	 *     (
	 *         strType=EString 
	 *         strId=EString 
	 *         sid=EString? 
	 *         strName=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         (value=EString | value2=EFloat)? 
	 *         stringAppliedPropertyValues=EString? 
	 *         stringAppliedPropertyValueGroups=EString? 
	 *         statut=EString? 
	 *         stringFeatures=EString? 
	 *         stringInvolvedElements=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         stringOwnedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         stringOwnedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_AbstractPropertyValue(ISerializationContext context, AbstractPropertyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractType returns AbstractType
	 *
	 * Constraint:
	 *     (type=EString id=EString sid=EString? name=nameType? idType=EString?)
	 */
	protected void sequence_AbstractType(ISerializationContext context, AbstractType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityAllocation returns ActivityAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ActivityAllocation(ISerializationContext context, ActivityAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityEdge returns ActivityEdge
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         kindOfRate=RateKind? 
	 *         realizedFlow=EString? 
	 *         target=EString 
	 *         source=EString 
	 *         interrupts=EString? 
	 *         rate=ValueSpecification? 
	 *         probability=ValueSpecification? 
	 *         guard=ValueSpecification? 
	 *         weight=ValueSpecification?
	 *     )
	 */
	protected void sequence_ActivityEdge(ISerializationContext context, ActivityEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityGroup returns ActivityGroup
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         subGroups+=ActivityGroup? 
	 *         ownedNodes+=ActivityNode? 
	 *         ownedEdges+=ActivityEdge?
	 *     )
	 */
	protected void sequence_ActivityGroup(ISerializationContext context, ActivityGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActivityNode returns ActivityNode
	 *
	 * Constraint:
	 *     (type=EString id=EString sid=EString? name=nameType?)
	 */
	protected void sequence_ActivityNode(ISerializationContext context, ActivityNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns Association
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         navigableMembers=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedMembers+=ExchangeItemInstance*
	 *     )
	 */
	protected void sequence_Association(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CapabilityConfiguration returns CapabilityConfiguration
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         nameConfig=nameType? 
	 *         idType=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         inExchangeLinks=EString? 
	 *         outExchangeLinks=EString? 
	 *         composingLinks=EString? 
	 *         configuredCapability=EString? 
	 *         abstract=EString? 
	 *         actor=EString 
	 *         human=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedFunctionalAllocation+=ComponentFunctionalAllocation* 
	 *         ownedComponentExchanges+=ComponentExchange* 
	 *         ownedComponentExchangeCategories+=ComponentExchangeCategory*
	 *     )
	 */
	protected void sequence_CapabilityConfiguration(ISerializationContext context, CapabilityConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Class returns Class
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         kind=UnionKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         keyParts=EString? 
	 *         discriminant=EString? 
	 *         defaultProperty=EString? 
	 *         abstract=EString? 
	 *         final=EString? 
	 *         isPrimitive=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         nestedGeneralClasses+=GeneralClass* 
	 *         ownedStateMachines+=StateMachine* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedInformationRealizations+=InformationRealization*
	 *     )
	 */
	protected void sequence_Class(ISerializationContext context, org.xtext.example.newoamydsl.myDslnew.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Collection returns Collection
	 *
	 * Constraint:
	 *     (
	 *         typeCollection=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         kind=CollectionKind? 
	 *         aggregationKind=AggregationKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         type=EString? 
	 *         index=EString? 
	 *         abstract=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isPrimitive=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedDefaultValue+=DataValue* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg*
	 *     )
	 */
	protected void sequence_Collection(ISerializationContext context, Collection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommunicationLink returns CommunicationLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=CommunicationLinkKind? 
	 *         protocol=CommunicationLinkProtocol? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchangeItem=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_CommunicationLink(ISerializationContext context, CommunicationLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommunicationMean returns CommunicationMean
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         kind=ComponentExchangeKind? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizations=EString? 
	 *         convoyedInformations=EString? 
	 *         source=EString 
	 *         target=EString 
	 *         link=EString? 
	 *         oriented=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedComponentExchangeFunctionalExchangeAllocations+=ComponentExchangeFunctionalExchangeAllocation* 
	 *         ownedComponentExchangeRealizations+=ComponentExchangeRealization* 
	 *         ownedComponentExchangeEnds+=ComponentExchangeEnd*
	 *     )
	 */
	protected void sequence_CommunicationMean(ISerializationContext context, CommunicationMean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeAllocation returns ComponentExchangeAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeAllocation(ISerializationContext context, ComponentExchangeAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeCategory returns ComponentExchangeCategory
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchanges=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeCategory(ISerializationContext context, ComponentExchangeCategory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeEnd returns ComponentExchangeEnd
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         port=EString? 
	 *         part=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeEnd(ISerializationContext context, ComponentExchangeEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchangeFunctionalExchangeAllocation returns ComponentExchangeFunctionalExchangeAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeFunctionalExchangeAllocation(ISerializationContext context, ComponentExchangeFunctionalExchangeAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeSpecificationRealization returns ComponentExchangeRealization
	 *     ComponentExchangeRealization returns ComponentExchangeRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         componentOwnedPropertyValues+=AbstractPropertyValue* 
	 *         componentEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         componentOwnedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentExchangeRealization(ISerializationContext context, ComponentExchangeRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentExchange returns ComponentExchange
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=ComponentExchangeKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         realizations=EString? 
	 *         convoyedInformations=EString? 
	 *         source=EString 
	 *         target=EString 
	 *         link=EString? 
	 *         oriented=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedComponentExchangeFunctionalExchangeAllocations+=ComponentExchangeFunctionalExchangeAllocation* 
	 *         ownedComponentExchangeRealizations+=ComponentExchangeRealization* 
	 *         ownedComponentExchangeEnds+=ComponentExchangeEnd*
	 *     )
	 */
	protected void sequence_ComponentExchange(ISerializationContext context, ComponentExchange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentFunctionalAllocation returns ComponentFunctionalAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentFunctionalAllocation(ISerializationContext context, ComponentFunctionalAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentRealization returns ComponentRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ComponentRealization(ISerializationContext context, ComponentRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptCompliance returns ConceptCompliance
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         complyWithConcept=EString 
	 *         compliantCapability=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ConceptCompliance(ISerializationContext context, ConceptCompliance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptPkg returns ConceptPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedConceptPkgs+=ConceptPkg* 
	 *         ownedConcepts+=Concept*
	 *     )
	 */
	protected void sequence_ConceptPkg(ISerializationContext context, ConceptPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Concept
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         compliances=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         compositeLinks+=ItemInConcept*
	 *     )
	 */
	protected void sequence_Concept(ISerializationContext context, Concept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         (name=Initialization | name=Invariant) 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         constrElmts=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup? 
	 *         exprSpecification+=OpaqueExpression?
	 *     )
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ControlNode returns ControlNode
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=ControlNodeKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_ControlNode(ISerializationContext context, ControlNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataPkg returns DataPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedExchangeItems+=ExchangeItem* 
	 *         ownedAssociations+=Association* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedMessageReferences+=MessageReference* 
	 *         ownedDataPkgs+=DataPkg* 
	 *         ownedClasses+=Class* 
	 *         ownedKeyParts+=KeyPart* 
	 *         ownedCollections+=Collection* 
	 *         ownedUnits+=Unit* 
	 *         ownedDataTypes+=DataType* 
	 *         ownedSignals+=Signal* 
	 *         ownedMessages+=Message* 
	 *         ownedExceptions+=Exception* 
	 *         ownedStateEvents+=StateEvent*
	 *     )
	 */
	protected void sequence_DataPkg(ISerializationContext context, DataPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         discrete=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         pattern=EString? 
	 *         visibility=VisibilityKind? 
	 *         kind=NumericTypeKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         unit=EString? 
	 *         abstract=EString? 
	 *         final=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedInformationRealizations+=InformationRealization*
	 *     )
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityOperationalCapabilityInvolvement returns EntityOperationalCapabilityInvolvement
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         involved=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_EntityOperationalCapabilityInvolvement(ISerializationContext context, EntityOperationalCapabilityInvolvement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntityPkg returns EntityPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedParts+=Part* 
	 *         ownedComponentExchanges+=ComponentExchange* 
	 *         ownedComponentExchangeCategories+=ComponentExchangeCategory* 
	 *         ownedFunctionalLinks+=ExchangeLink* 
	 *         ownedFunctionalAllocations+=ComponentFunctionalAllocation* 
	 *         ownedComponentExchangeRealizations+=ComponentExchangeRealization* 
	 *         ownedPhysicalLinks+=PhysicalLink* 
	 *         ownedStateMachines+=StateMachine* 
	 *         ownedEntities+=Entity* 
	 *         ownedEntityPkgs+=EntityPkg* 
	 *         ownedLocations+=Location* 
	 *         ownedCommunicationMeans+=CommunicationMean*
	 *     )
	 */
	protected void sequence_EntityPkg(ISerializationContext context, EntityPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         inExchangeLinks=EString? 
	 *         outExchangeLinks=EString? 
	 *         composingLinks=EString? 
	 *         organisationalUnitMemberships=EString? 
	 *         actualLocation=EString? 
	 *         abstract=EString? 
	 *         actor=EString? 
	 *         human=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         constraint+=Constraint* 
	 *         ownedFunctionalAllocation+=ComponentFunctionalAllocation* 
	 *         ownedComponentExchanges+=ComponentExchange* 
	 *         ownedComponentExchangeCategories+=ComponentExchangeCategory* 
	 *         ownedStateMachines+=StateMachine* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedInterfaceAllocations+=InterfaceAllocation* 
	 *         ownedCommunicationLinks+=CommunicationLink* 
	 *         ownedInterfaceUses+=InterfaceUse* 
	 *         ownedInterfaceImplementations+=InterfaceImplementation* 
	 *         ownedComponentRealizations+=ComponentRealization* 
	 *         ownedPhysicalPath+=PhysicalPath* 
	 *         ownedPhysicalLinks+=PhysicalLink* 
	 *         ownedEntities+=Entity* 
	 *         ownedCommunicationMeans+=CommunicationMean* 
	 *         ownedRoleAllocations+=RoleAllocation*
	 *     )
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationPropertyLiteral returns EnumerationPropertyLiteral
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=[AbstractPropertyValue|EString]? 
	 *         appliedPropertyValueGroups+=[PropertyValueGroup|EString]? 
	 *         statut=EString? 
	 *         features=[EnumerationPropertyLiteral|EString]? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_EnumerationPropertyLiteral(ISerializationContext context, EnumerationPropertyLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationPropertyType returns EnumerationPropertyType
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         statut=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedLiterals+=EnumerationPropertyLiteral?
	 *     )
	 */
	protected void sequence_EnumerationPropertyType(ISerializationContext context, EnumerationPropertyType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExceptionHandler returns ExceptionHandler
	 *
	 * Constraint:
	 *     (type=EString handlerBody=EString exceptionInput=EString exceptionTypes=EString)
	 */
	protected void sequence_ExceptionHandler(ISerializationContext context, ExceptionHandler semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_Type()));
			if (transientValues.isValueTransient(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_HandlerBody()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_HandlerBody()));
			if (transientValues.isValueTransient(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_ExceptionInput()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_ExceptionInput()));
			if (transientValues.isValueTransient(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_ExceptionTypes()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslnewPackage.eINSTANCE.getExceptionHandler_ExceptionTypes()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getTypeEStringTerminalRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getHandlerBodyEStringTerminalRuleCall_4_0(), semanticObject.getHandlerBody());
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getExceptionInputEStringTerminalRuleCall_6_0(), semanticObject.getExceptionInput());
		feeder.accept(grammarAccess.getExceptionHandlerAccess().getExceptionTypesEStringTerminalRuleCall_8_0(), semanticObject.getExceptionTypes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exception returns Exception
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedStateMachines+=StateMachine*
	 *     )
	 */
	protected void sequence_Exception(ISerializationContext context, org.xtext.example.newoamydsl.myDslnew.Exception semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeCategory returns ExchangeCategory
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchanges=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeCategory(ISerializationContext context, ExchangeCategory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeContainment returns ExchangeContainment
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchange=EString 
	 *         link=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeContainment(ISerializationContext context, ExchangeContainment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeItemAllocation returns ExchangeItemAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         sendProtocol=CommunicationLinkProtocol? 
	 *         receiveProtocol=CommunicationLinkProtocol? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         allocatedItem=EString? 
	 *         final=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeItemAllocation(ISerializationContext context, ExchangeItemAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeItemElement returns ExchangeItemElement
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=ElementKind? 
	 *         direction=ParameterDirection? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         referencedProperties=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         composite=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeItemElement(ISerializationContext context, ExchangeItemElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeItemInstance returns ExchangeItemInstance
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         aggregationKind=AggregationKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         qualifier=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         uniqu=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ExchangeItemInstance(ISerializationContext context, ExchangeItemInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeItem returns ExchangeItem
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         exchangeMechanism=ExchangeMechanism 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedElements+=ExchangeItemElement* 
	 *         ownedInformationRealizations+=InformationRealization*
	 *     )
	 */
	protected void sequence_ExchangeItem(ISerializationContext context, ExchangeItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExchangeLink returns ExchangeLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         exchangeContainmentLinks=EString? 
	 *         sources=EString? 
	 *         destinations=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedExchangeContainments+=ExchangeContainment*
	 *     )
	 */
	protected void sequence_ExchangeLink(ISerializationContext context, ExchangeLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPkg returns FunctionPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         functionPkgName=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=[EnumerationPropertyLiteral|EString]? 
	 *         features=[EnumerationPropertyLiteral|EString]? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedFunctionalLinks+=ExchangeLink* 
	 *         ownedExchanges+=FunctionalExchangeSpecification* 
	 *         ownedExchangeSpecificationRealizations+=ExchangeSpecificationRealization* 
	 *         ownedCategories+=ExchangeCategory* 
	 *         ownedFunctionSpecifications+=FunctionSpecification* 
	 *         ownedOperationalActivities+=OperationalActivity*
	 *     )
	 */
	protected void sequence_FunctionPkg(ISerializationContext context, FunctionPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionRealization returns FunctionRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionRealization(ISerializationContext context, FunctionRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionSpecification returns FunctionSpecification
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedParameterSet=EString? 
	 *         ownedParameter=EString? 
	 *         inExchangeLinks=EString? 
	 *         outExchangeLinks=EString? 
	 *         isControlOperator=EString? 
	 *         isReadOnly=EString? 
	 *         isSingleExecution=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace? 
	 *         ownedNodes+=ActivityNode? 
	 *         ownedEdges+=ActivityEdge? 
	 *         ownedGroups+=ActivityGroup?
	 *     )
	 */
	protected void sequence_FunctionSpecification(ISerializationContext context, FunctionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalChainInvolvement returns FunctionalChainInvolvementLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         chainInvAppliedPropertyValues=EString? 
	 *         chainInvAppliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         chainInvFeatures=EString? 
	 *         involved=EString 
	 *         sourceReferenceHierarchy=EString? 
	 *         targetReferenceHierarchy=EString? 
	 *         exchangeContext=EString? 
	 *         exchangedItems=EString? 
	 *         source=EString? 
	 *         target=EString? 
	 *         chainInvOwnedPropertyValues+=AbstractPropertyValue? 
	 *         chainInvOwnedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         chainInvOwnedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionalChainInvolvement(ISerializationContext context, FunctionalChainInvolvementLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalChainRealization returns FunctionalChainRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionalChainRealization(ISerializationContext context, FunctionalChainRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalChain returns FunctionalChain
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=FunctionalChainKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         availableInStates=EString? 
	 *         preCondition=EString? 
	 *         postCondition=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup? 
	 *         ownedFunctionalChainInvolvements+=FunctionalChainInvolvement* 
	 *         ownedFunctionalChainRealizations+=FunctionalChainRealization* 
	 *         ownedSequenceNodes+=ControlNode* 
	 *         ownedSequenceLinks+=SequenceLink*
	 *     )
	 */
	protected void sequence_FunctionalChain(ISerializationContext context, FunctionalChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalExchangeRealization returns FunctionalExchangeRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_FunctionalExchangeRealization(ISerializationContext context, FunctionalExchangeRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalExchangeSpecification returns FunctionalExchangeSpecification
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         realizations=EString? 
	 *         convoyedInformations=EString? 
	 *         source=EString 
	 *         target=EString 
	 *         link=EString? 
	 *         exchangeOwnedPropertyValues+=AbstractPropertyValue* 
	 *         exchangeEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         exchangeOwnedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_FunctionalExchangeSpecification(ISerializationContext context, FunctionalExchangeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalExchange returns FunctionalExchange
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=ID 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kindOfRate=RateKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         target=EString 
	 *         source=EString 
	 *         interrupts=EString? 
	 *         transformation=EString? 
	 *         selection=EString? 
	 *         exchangeSpecifications=EString? 
	 *         exchangedItems=EString? 
	 *         isMulticast=EString? 
	 *         isMultireceive=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup? 
	 *         rate=ValueSpecification? 
	 *         probability=ValueSpecification? 
	 *         guard=ValueSpecification? 
	 *         weight=ValueSpecification? 
	 *         ownedFunctionalExchangeRealizations+=FunctionalExchangeRealization?
	 *     )
	 */
	protected void sequence_FunctionalExchange(ISerializationContext context, FunctionalExchange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeneralClass returns GeneralClass
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         idType=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstract=EString? 
	 *         final=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         nestedGeneralClasses+=GeneralClass*
	 *     )
	 */
	protected void sequence_GeneralClass(ISerializationContext context, GeneralClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Generalization returns Generalization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         super=EString 
	 *         sub=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_Generalization(ISerializationContext context, Generalization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InformationRealization returns InformationRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         (ownedPropertyValues+=AbstractPropertyValue ownedPropertyValues+=AbstractPropertyValue*)? 
	 *         (ownedEnumerationPropertyTypes+=EnumerationPropertyType ownedEnumerationPropertyTypes+=EnumerationPropertyType*)? 
	 *         (ownedPropertyValueGroups+=PropertyValueGroup ownedPropertyValueGroups+=PropertyValueGroup*)?
	 *     )
	 */
	protected void sequence_InformationRealization(ISerializationContext context, InformationRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initialization returns Initialization
	 *
	 * Constraint:
	 *     name=nameType
	 */
	protected void sequence_Initialization(ISerializationContext context, Initialization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslnewPackage.eINSTANCE.getInitialization_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslnewPackage.eINSTANCE.getInitialization_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitializationAccess().getNameNameTypeParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputOutputPin returns InputOutputPin
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         kindOfNode=ObjectNodeKind? 
	 *         ordering=ObjectNodeOrderingKind? 
	 *         abstractType=EString? 
	 *         inState=EString? 
	 *         selection=EString? 
	 *         inputEvaluationAction=EString? 
	 *         isControlType=EString? 
	 *         isControl=EString? 
	 *         upperBound=ValueSpecification?
	 *     )
	 */
	protected void sequence_InputOutputPin(ISerializationContext context, InputOutputPin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceAllocation returns InterfaceAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_InterfaceAllocation(ISerializationContext context, InterfaceAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceImplementation returns InterfaceImplementation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         implementedInterface=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_InterfaceImplementation(ISerializationContext context, InterfaceImplementation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfacePkg returns InterfacePkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedMessageReferences+=MessageReference* 
	 *         ownedExchangeItems+=ExchangeItem* 
	 *         ownedInterfaces+=Interface* 
	 *         ownedInterfacePkgs+=InterfacePkg*
	 *     )
	 */
	protected void sequence_InterfacePkg(ISerializationContext context, InterfacePkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceUse returns InterfaceUse
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         usedInterface=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_InterfaceUse(ISerializationContext context, InterfaceUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Interface returns Interface
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         mechanism=EString? 
	 *         structural=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstract=EString? 
	 *         final=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         nestedGeneralClasses+=GeneralClass* 
	 *         ownedInterfaceAllocations+=InterfaceAllocation* 
	 *         ownedExchangeItemAllocations+=ExchangeItemAllocation*
	 *     )
	 */
	protected void sequence_Interface(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Invariant returns Invariant
	 *
	 * Constraint:
	 *     (leftPart=nameType rightPart=nameType)
	 */
	protected void sequence_Invariant(ISerializationContext context, Invariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslnewPackage.eINSTANCE.getInvariant_LeftPart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslnewPackage.eINSTANCE.getInvariant_LeftPart()));
			if (transientValues.isValueTransient(semanticObject, MyDslnewPackage.eINSTANCE.getInvariant_RightPart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslnewPackage.eINSTANCE.getInvariant_RightPart()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantAccess().getLeftPartNameTypeParserRuleCall_1_0(), semanticObject.getLeftPart());
		feeder.accept(grammarAccess.getInvariantAccess().getRightPartNameTypeParserRuleCall_3_0(), semanticObject.getRightPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ItemInConcept returns ItemInConcept
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         concept=EString 
	 *         item=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_ItemInConcept(ISerializationContext context, ItemInConcept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyPart returns KeyPart
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         property=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_KeyPart(ISerializationContext context, KeyPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns Location
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         locationDescription=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         inExchangeLinks=EString? 
	 *         outExchangeLinks=EString? 
	 *         composingLinks=EString? 
	 *         locatedEntities=EString? 
	 *         abstract=EString? 
	 *         actor=EString? 
	 *         human=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedFunctionalAllocation+=ComponentFunctionalAllocation*
	 *     )
	 */
	protected void sequence_Location(ISerializationContext context, Location semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageReference returns MessageReference
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         message=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_MessageReference(ISerializationContext context, MessageReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstract=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedStateMachines+=StateMachine*
	 *     )
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OpaqueExpression returns OpaqueExpression
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         nameSpecification=nameType? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         bodies=EString? 
	 *         languages=ID? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_OpaqueExpression(ISerializationContext context, OpaqueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationalActivityPkg returns OperationalActivityPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         functionPkgName=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=[EnumerationPropertyLiteral|EString]? 
	 *         features=[EnumerationPropertyLiteral|EString]? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedOperationalActivityPkgs+=OperationalActivityPkg* 
	 *         ownedOperationalActivities+=OperationalActivity*
	 *     )
	 */
	protected void sequence_OperationalActivityPkg(ISerializationContext context, OperationalActivityPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationalActivity returns OperationalActivity
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         nameOpActivities=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         aggregationKind=AggregationKind? 
	 *         idType=EString? 
	 *         kind=FunctionKind? 
	 *         condition=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         context=EString? 
	 *         behavior=EString? 
	 *         availableInStates=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedDefaultValue+=DataValue* 
	 *         ownedFunctionalChains+=FunctionalChain* 
	 *         ownedHandlers+=ExceptionHandler* 
	 *         ownedOperationalActivityPkgs+=OperationalActivityPkg 
	 *         inputsOutputsPins+=InputOutputPin* 
	 *         ownedFunctions+=AbstractFunction* 
	 *         ownedFunctionRealizations+=FunctionRealization* 
	 *         functionalExchange+=FunctionalExchange*
	 *     )
	 */
	protected void sequence_OperationalActivity(ISerializationContext context, OperationalActivity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationalCapabilityPkg returns OperationalCapabilityPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         nameCapPkg=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedOperationalCapabilities+=OperationalCapability* 
	 *         ownedOperationalCapabilityPkgs+=OperationalCapabilityPkg* 
	 *         ownedCapabilityConfigurations+=CapabilityConfiguration* 
	 *         ownedConceptCompliances+=ConceptCompliance*
	 *     )
	 */
	protected void sequence_OperationalCapabilityPkg(ISerializationContext context, OperationalCapabilityPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationalCapability returns OperationalCapability
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         nameCapability=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         compliances=EString? 
	 *         configurations=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedEntityOperationalCapabilityInvolvements+=EntityOperationalCapabilityInvolvement*
	 *     )
	 */
	protected void sequence_OperationalCapability(ISerializationContext context, OperationalCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Part returns Part
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         aggregationKind=AggregationKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedDefaultValue+=DataValue* 
	 *         ownedDeploymentLinks+=AbstractDeploymentLink* 
	 *         ownedAbstractType=AbstractType?
	 *     )
	 */
	protected void sequence_Part(ISerializationContext context, Part semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalLinkEnd returns PhysicalLinkEnd
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         port=EString? 
	 *         part=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalLinkEnd(ISerializationContext context, PhysicalLinkEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalLinkRealization returns PhysicalLinkRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalLinkRealization(ISerializationContext context, PhysicalLinkRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalLink returns PhysicalLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         linkEnds=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedComponentExchangeAllocations+=ComponentExchangeAllocation* 
	 *         ownedComponentExchangeFunctionalExchangeAllocations+=ComponentExchangeFunctionalExchangeAllocation* 
	 *         ownedPhysicalLinkEnds+=PhysicalLinkEnd* 
	 *         ownedPhysicalLinkRealizations+=PhysicalLinkRealization*
	 *     )
	 */
	protected void sequence_PhysicalLink(ISerializationContext context, PhysicalLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalPathInvolvement returns PhysicalPathInvolvement
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         involved=EString 
	 *         nextInvolvements=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_PhysicalPathInvolvement(ISerializationContext context, PhysicalPathInvolvement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PhysicalPath returns PhysicalPath
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         involvedLinks=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedComponentExchangeAllocations+=ComponentExchangeAllocation* 
	 *         ownedPhysicalPathInvolvements+=PhysicalPathInvolvement*
	 *     )
	 */
	protected void sequence_PhysicalPath(ISerializationContext context, PhysicalPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyValueGroup returns PropertyValueGroup
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         statut=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace?
	 *     )
	 */
	protected void sequence_PropertyValueGroup(ISerializationContext context, PropertyValueGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyValuePkg returns PropertyValuePkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace? 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg*
	 *     )
	 */
	protected void sequence_PropertyValuePkg(ISerializationContext context, PropertyValuePkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Region returns Region
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         ppliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         involvedStates=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTransitions+=StateTransition*
	 *     )
	 */
	protected void sequence_Region(ISerializationContext context, Region semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         requirementId=EString? 
	 *         additionalInformation=EString? 
	 *         verificationMethod=EString? 
	 *         verificationPhase=EString? 
	 *         implementationVersion=EString? 
	 *         feature=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         wnedTraces+=Trace*
	 *     )
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsPkg returns RequirementsPkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         additionalInformation=EString? 
	 *         level=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedRequirements+=Requirement* 
	 *         ownedRequirementPkgs+=RequirementsPkg*
	 *     )
	 */
	protected void sequence_RequirementsPkg(ISerializationContext context, RequirementsPkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RoleAllocation returns RoleAllocation
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_RoleAllocation(ISerializationContext context, RoleAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RoleAssemblyUsage returns RoleAssemblyUsage
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         child=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_RoleAssemblyUsage(ISerializationContext context, RoleAssemblyUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RolePkg returns RolePkg
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         nameRolePkg=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedRolePkgs+=RolePkg* 
	 *         ownedRoles+=Role*
	 *     )
	 */
	protected void sequence_RolePkg(ISerializationContext context, RolePkg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Role returns Role
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         nameRole=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         aggregationKind=AggregationKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedDefaultValue+=DataValue* 
	 *         ownedRoleAssemblyUsages+=RoleAssemblyUsage* 
	 *         constraint+=Constraint* 
	 *         ownedActivityAllocations+=ActivityAllocation*
	 *     )
	 */
	protected void sequence_Role(ISerializationContext context, Role semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SequenceLink returns SequenceLink
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         sourceReferenceHierarchy=EString? 
	 *         targetReferenceHierarchy=EString? 
	 *         condition=EString? 
	 *         links=EString? 
	 *         source=EString? 
	 *         target=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue? 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType? 
	 *         ownedPropertyValueGroups+=PropertyValueGroup?
	 *     )
	 */
	protected void sequence_SequenceLink(ISerializationContext context, SequenceLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignalInstance returns SignalInstance
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         aggregationKind=AggregationKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         isAbstract=EString? 
	 *         isStatic=EString? 
	 *         ordered=EString? 
	 *         unique=EString? 
	 *         minInclusive=EString? 
	 *         maxInclusive=EString? 
	 *         final=EString? 
	 *         isDerived=EString? 
	 *         isReadOnly=EString? 
	 *         isPartOfKey=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedDefaultValue+=DataValue*
	 *     )
	 */
	protected void sequence_SignalInstance(ISerializationContext context, SignalInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signal returns Signal
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         visibility=VisibilityKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstract=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedGeneralizations+=Generalization* 
	 *         ownedFeatures+=Feature* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedDataValues+=DataValue* 
	 *         ownedStateMachines+=StateMachine* 
	 *         signalInstances+=SignalInstance*
	 *     )
	 */
	protected void sequence_Signal(ISerializationContext context, Signal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateEventRealization returns StateEventRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         ppliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_StateEventRealization(ISerializationContext context, StateEventRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateEvent returns StateEvent
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=EventKind? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         expression=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedStateEventRealizations+=StateEventRealization*
	 *     )
	 */
	protected void sequence_StateEvent(ISerializationContext context, StateEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateMachine returns StateMachine
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         name=nameType? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedParameterSet=EString? 
	 *         ownedParameter=EString? 
	 *         isControlOperator=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedRegions+=Region*
	 *     )
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateTransitionRealization returns StateTransitionRealization
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizedFlow=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_StateTransitionRealization(ISerializationContext context, StateTransitionRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateTransition returns StateTransition
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         kind=TransitionKind? 
	 *         triggerDescription=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         realizedFlow=EString? 
	 *         guard=EString? 
	 *         source=EString 
	 *         target=EString 
	 *         effect=EString? 
	 *         triggers=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedStateTransitionRealizations+=StateTransitionRealization*
	 *     )
	 */
	protected void sequence_StateTransition(ISerializationContext context, StateTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trace returns Trace
	 *
	 * Constraint:
	 *     (
	 *         typeTrace=EString 
	 *         idTrace=EString 
	 *         sid=EString? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         realizFlow=EString? 
	 *         appliedPropertyValues=[AbstractPropertyValue|EString]? 
	 *         appliedPropertyValueGroups=[PropertyValueGroup|EString]? 
	 *         statut=EString? 
	 *         features=[EnumerationPropertyLiteral|EString]? 
	 *         targetElement=EString 
	 *         sourceElement=EString 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_Trace(ISerializationContext context, Trace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         name=nameType? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup*
	 *     )
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueSpecification returns ValueSpecification
	 *
	 * Constraint:
	 *     (type=EString id=EString sid=EString? name=nameType? abstractType=EString?)
	 */
	protected void sequence_ValueSpecification(ISerializationContext context, ValueSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataValue returns ValueTag
	 *     ValueTag returns ValueTag
	 *
	 * Constraint:
	 *     (
	 *         objectType=EString 
	 *         id=EString 
	 *         sid=EString? 
	 *         (nameValue=nameType | nameValue=EmptyString)? 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         abstractType=EString? 
	 *         referencedValue=EString? 
	 *         referencedProperty=EString? 
	 *         unit=EString? 
	 *         boolValAbstract=EString? 
	 *         value=EString? 
	 *         ooperator=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         domainValue+=DataValue*
	 *     )
	 */
	protected void sequence_ValueTag(ISerializationContext context, ValueTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     operationalAnalysis returns operationalAnalysis
	 *
	 * Constraint:
	 *     (
	 *         type=EString 
	 *         architectureId=EString 
	 *         sid=EString? 
	 *         architectureName=nameType 
	 *         visibleInDoc=EString? 
	 *         visibleInLM=EString? 
	 *         summary=EString? 
	 *         description=EString? 
	 *         review=EString? 
	 *         appliedPropertyValues=EString? 
	 *         appliedPropertyValueGroups=EString? 
	 *         status=EString? 
	 *         features=EString? 
	 *         ownedPropertyValues+=AbstractPropertyValue* 
	 *         ownedEnumerationPropertyTypes+=EnumerationPropertyType* 
	 *         ownedPropertyValueGroups+=PropertyValueGroup* 
	 *         ownedTraces+=Trace* 
	 *         ownedPropertyValuePkgs+=PropertyValuePkg* 
	 *         ownedFunctionPkg=FunctionPkg? 
	 *         containedOperationalCapabilityPkg=OperationalActivityPkg? 
	 *         ownedComponentExchanges+=ComponentExchange* 
	 *         ownedComponentExchangeCategories+=ComponentExchangeCategory* 
	 *         ownedFunctionalLinks+=ExchangeLink* 
	 *         ownedRequirementPkgs+=RequirementsPkg* 
	 *         containedOperationalActivityPkg=OperationalCapabilityPkg? 
	 *         ownedInterfacePkg=InterfacePkg? 
	 *         ownedDataPkg=DataPkg? 
	 *         ownedRolePkg=RolePkg? 
	 *         ownedEntityPkg=EntityPkg? 
	 *         ownedConceptPkg=ConceptPkg?
	 *     )
	 */
	protected void sequence_operationalAnalysis(ISerializationContext context, operationalAnalysis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
