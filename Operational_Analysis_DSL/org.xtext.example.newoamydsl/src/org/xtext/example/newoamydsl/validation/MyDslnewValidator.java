/*
 * generated by Xtext 2.22.0
 */
package org.xtext.example.newoamydsl.validation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.newoamydsl.myDslnew.AbstractFunction;
import org.xtext.example.newoamydsl.myDslnew.Constraint;
import org.xtext.example.newoamydsl.myDslnew.Entity;
import org.xtext.example.newoamydsl.myDslnew.EntityPkg;
import org.xtext.example.newoamydsl.myDslnew.FunctionalExchange;
import org.xtext.example.newoamydsl.myDslnew.Initialization;
import org.xtext.example.newoamydsl.myDslnew.Invariant;
import org.xtext.example.newoamydsl.myDslnew.OperationalActivity;
import org.xtext.example.newoamydsl.myDslnew.Role;
import org.xtext.example.newoamydsl.myDslnew.RolePkg;
import org.xtext.example.newoamydsl.myDslnew.operationalAnalysis;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MyDslnewValidator extends AbstractMyDslnewValidator {
	
	@Check
	public void checkOASyntax(operationalAnalysis architecture, List<String> errors) {
		
		EList<OperationalActivity> opActivities = architecture.getOwnedFunctionPkg().getOwnedOperationalActivities();
		EList<AbstractFunction> functions = opActivities.get(0).getOwnedFunctions();
		RolePkg rolePkg = architecture.getOwnedRolePkg();
		EList<Role> roles = rolePkg.getOwnedRoles();
		EntityPkg entityPkg = architecture.getOwnedEntityPkg();
		
		EList<Entity> entities = entityPkg.getOwnedEntities();
		List<String> functions2 = new ArrayList<>();
		List<String> entities2 = new ArrayList<>();
		List<String> roles2 = new ArrayList<>();
		
		
		List<String> exchangeValues = getFunctionalExchanges(opActivities.get(0));
		List<String> valuesToAddFronInit = new ArrayList<>();
		List<String> constValuesList = new ArrayList<>();
		
		//Check that the functions don't have the same name
		for(AbstractFunction function : functions) {
			EList<Constraint> constraintsObjs = function.getOwnedConstraints();
			
			getAllInitializations(constraintsObjs, exchangeValues, valuesToAddFronInit, constValuesList, true);
			
			String functionNameValue = function.getName();
			checkNames(functions2, functionNameValue, "activity", function, errors);
		}
		
		//Check that the roles don't have the same name
		for(Role role : roles) {
			EList<Constraint> constraintsObjs = role.getConstraint();
			
			getAllInitializations(constraintsObjs, exchangeValues, valuesToAddFronInit, constValuesList, false);
			
			String roleNameValue = role.getNameRole();
			checkNames(roles2, roleNameValue, "role", role, errors);
		}
		
		//Check that the entities don't have the same name
		for(Entity entity : entities) {
            parseEntities(entity, exchangeValues, valuesToAddFronInit, constValuesList, errors, entities2);
		}
		
		exchangeValues.addAll(valuesToAddFronInit);
		
		parseConstraints(constValuesList, errors, exchangeValues);
		
	}
	
	//
	public void parseEntities(Entity entityObj, List<String> exchangeValues, List<String> valuesToAddFronInit,
	                     List<String> constValuesList, List<String> errors, List<String> entities2) {
		
		EList<Constraint> constraintsObjs = entityObj.getConstraint();
		
        getAllInitializations(constraintsObjs, exchangeValues, valuesToAddFronInit, constValuesList, false);
		
		String entityNameValue = entityObj.getName();
		checkNames(entities2, entityNameValue, "entity", entityObj, errors);
		
		List<Entity> subEntities = entityObj.getOwnedEntities();
		for(Entity subEntity : subEntities) {
			parseEntities(subEntity, exchangeValues, valuesToAddFronInit, constValuesList, errors, entities2);
		}
	}
	
	
    // get the list of the functioanl exchanges values    
    public List<String> getFunctionalExchanges(OperationalActivity operationalActivities){
    	List<String> exchangesValues = new ArrayList<>();
    	// Find the corresponding FunctionalExchange elements
        EList<FunctionalExchange> functionalExchanges = new BasicEList<>();
        functionalExchanges.addAll(operationalActivities.getFunctionalExchange());
        for (FunctionalExchange exchange : functionalExchanges) {
            exchangesValues.add(exchange.getName());
        }
        return exchangesValues;
    }
    
    //Chech the unicity of name value
	public void checkNames(List<String> listOfNames, String value, String msg, EObject object, List<String> errors) {
		if (listOfNames.contains(value)) {
			errors.add("The name of the " + msg +" \""+ value +"\" exists already, please change it.");
		} else {
			listOfNames.add(value);
		}
	}
    
    public static boolean checkConstraintSyntax(String constValue, List<String> errors, List<String> exchangeValues) {
		List<String> filteredElements = Arrays.stream(constValue.split(" "))
				// Replace parentheses, &amp;, and or
				.map(element -> element.replace("(", "").replace(")", ""))
				.filter(element -> !element.equals("(") && !element.equals(")") && !element.equals("&amp;")
						&& !element.equals("or"))
				// Split elements by "not()" pattern and flatten the resulting stream
				.flatMap(element -> {
					if (element.startsWith("not(")) {
						return Arrays.stream(new String[] { element.substring(4, element.length() - 1) });
					} else if (element.startsWith("not")) {
						return Arrays.stream(new String[] { element.substring(3) });
					}
					return Arrays.stream(new String[] { element });
				}).filter(element -> !element.isEmpty()).collect(Collectors.toList());

		boolean isCorrectConst = filteredElements.stream().allMatch(element -> exchangeValues.contains(element));
		boolean constValid = true;
		
		if (!isCorrectConst && errors != null) {
			errors.add("The Constraint { " + constValue
					+ " } must be composed of names from FunctionalExchange elements.");
		} else {
			constValid = isValidExpression(constValue);
			if (!constValid && errors != null) {
				errors.add("The semantic of the constraint { " + constValue + " } is incorrect.");
			}
		}
		
		return isCorrectConst && constValid;
    }
    
    public static boolean isAnOperator(char c) {
	    switch (c) {
	        case '&':
	        case 'o':
	            return true;
	        default:
	            return false;
	    }
	}

	public static boolean isValidExpression(String expression) {
		
	    int openParenthCount = 0;
	    boolean lastWasOp = false;
	    boolean lastWasOpen = false;

	    StringBuilder modifiedExpression = new StringBuilder();
        
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
	        if (c == ' ') {
	        	continue;
	        }

	        if (c == '(') {
	            openParenthCount++;
	            lastWasOpen = true;
	            modifiedExpression.append(c);
	            continue;
	        } else if (c == ')') {
	            if (openParenthCount <= 0 || lastWasOp) {
	                return false;
	            }
	            openParenthCount--;
	            modifiedExpression.append(c);
	        } else if (isAnOperator(c)) {
	            if (lastWasOp || lastWasOpen) return false;

	            if (c == '&') {
	            	if (i + 4 < expression.length() && expression.substring(i, i + 5).equalsIgnoreCase("&amp;")) {
	                    i += 4; // Skip the next three characters as they are part of '&amp;'
	                } else {
	                    return false; // Invalid '&amp;' operator
	                }
	            	
	                //modifiedExpression.append("&amp;");
				} else if (c == 'o') {
					if (expression.charAt(i - 1) == ' ' && i + 1 < expression.length()
							&& (expression.charAt(i + 1) == 'r' || expression.charAt(i + 1) == 'R')) {
						
						i++; // Skip the next character as it is part of 'or'
					}
				}

	            lastWasOp = true;
	            continue;
	        }

	        lastWasOp = false;
	        lastWasOpen = false;
	    }

	    if (openParenthCount != 0) return false;
	    if (lastWasOp || lastWasOpen) return false;

	    return true;
	}
    
   
    // Parse the constraints to check if it's intialization or invarinat, if it's the case, then verify the syntax
	public static void parseConstraints(List<String> constValuesList, List<String> errors, List<String> exchangeValues) {
		for (String constValue : constValuesList) {

			// syntax check for the initialization
			if (constValue.startsWith("=")) {
				List<String> initializationElements = Arrays.stream(constValue.split(" "))
						.map(element -> element.replace(" ", "")).collect(Collectors.toList());
				initializationElements.remove(0);
				boolean isCorrectInitialization = initializationElements.size() == 1
						&& initializationElements.stream().allMatch(element -> exchangeValues.contains(element));
				if (!isCorrectInitialization) {
					errors.add("This initialization " + constValue + " is not correct.");
				}
			} else if (constValue.startsWith(":")) {
				String[] left_right_parts = constValue.split("\\s*>>\\s*");
                
				String leftPartStr = left_right_parts[0].substring(1);
				
		        String rightPartStr = Arrays.stream(left_right_parts)
					                        .skip(1).map(String::trim).findFirst()
					                        .orElse("");

				if (leftPartStr != null && rightPartStr == null) {
					errors.add("The constraint " + leftPartStr + " is not correct. The character >> is missing.");
				} else if (leftPartStr == null && rightPartStr != null) {
					errors.add("The constraint " + rightPartStr + " is not correct. The character >> is missing.");
				} else if (leftPartStr != null && rightPartStr != null) {
					boolean isLeftPartValid = checkConstraintSyntax(leftPartStr, null, exchangeValues);
					boolean isRightPartValid = checkConstraintSyntax(rightPartStr, null, exchangeValues);

					if (!isLeftPartValid || !isRightPartValid) {
						errors.add("The constraint " + leftPartStr + " >> " + rightPartStr + " is incorrect.");
					}
				}
			} else {
				checkConstraintSyntax(constValue, errors, exchangeValues);
			}
		}
	}
	
    // get the list of all the intialization values (constraints that start with "=")
    public static void getAllInitializations(EList<Constraint> constraintsObjs, List<String> exchangeValues, List<String> valuesToAddFronInit,
    		List<String> constValuesList, boolean isFunction) {
    	
		for (Constraint constrObj : constraintsObjs) {

			EObject constImplObject = constrObj.getName();
			String constValue = "";

			if (constImplObject instanceof Initialization) {
				String constraintValue = ((Initialization) constImplObject).getName();
				if(isFunction) {
					constValuesList.add(constraintValue);
				}else{
					valuesToAddFronInit.add(constraintValue);
					constValue = "= ".concat(constraintValue);
					constValuesList.add(constValue);
				}
				
			} else if (constImplObject instanceof Invariant) {
				constValue = ":".concat(((Invariant) constImplObject).getLeftPart()).concat(">>").concat(((Invariant) constImplObject).getRightPart());
				constValuesList.add(constValue);		
			}
		}
    }
	
}
